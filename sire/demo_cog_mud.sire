#### demo_cog_mud <- prelude

;[ 8] [ 9] [13] [14];
;[ 1] [ 7] [ 2] [10];
;[ 3] [ 4] [ 5] [11];
;[ 0] [ 6] [ 0] [12];

; TODO / IDEAS
; - [x] room descriptions
; - [ ] chat (local, no history)
; - [ ] discuss (fora, many connected rooms, with log)
; - [ ] yell (all rooms, with log)
; - [ ] manifest items
; - [ ] allow for defining rooms, items, etc. all state in a separate file
;       that gets ingested here.
; - [ ] generate stuff in rooms from random tables
;   - [ ] then add AI...
; - [ ] doors that open and close
; - [ ] seen/unseen rooms
; - [ ] line of sight? (don't show things going on in rooms you can't see)
; - [ ] sounds?
; - [ ] range of sound (like line of sight)

:| sire
:| prelude
:| kern
:| json
:| hitch
:| stew
:| gen

# typedef ContentType Bar

> Bar > Maybe Nat
= (parseNat bar)
@ wid (barLen bar)
@ hed (barIdx 0 bar)
| maybeGuardNot (isZero wid)
| maybeGuard    (isDigit hed)
@ acc (sub hed {0})
^ (_ acc 1)
? (go acc ix)
| if (gte ix wid) (SOME acc)
@ c (barGet bar ix)
| maybeGuard (isDigit c)
@ !acc (add (mul 10 acc) (sub c {0}))
| go acc inc-ix


= grid
, [8 9 13 14]
  [1 7 2 10]
  [3 4 5 11]
  [0 6 0 12]

; exits: [0 0 3 0]
;         n e s w
= rooms
| tabFromPairs
++  , 1 ; room ID
    | tabFromPairs
    , [b#exits [8 7 3 0]]
      [b#desc b#{it's damp and sticky}]
++  , 2
    | tabFromPairs
    , [b#exits [13 10 5 7]]
      [b#desc b#{the ceiling here is so high you can't see it}]
++  , 3
    | tabFromPairs
    , [b#exits [1 4 0 0]]
      [b#desc b#{}]
++  , 4
    | tabFromPairs
    , [b#exits [7 5 6 3]]
      [b#desc b#{}]
++  , 5
    | tabFromPairs
    , [b#exits [2 11 0 4]]
      [b#desc b#{}]
++  , 6
    | tabFromPairs
    , [b#exits [4 0 0 0]]
      [b#desc b#{}]
++  , 7
    | tabFromPairs
    , [b#exits [9 2 4 1]]
      [b#desc b#{}]
++  , 8
    | tabFromPairs
    , [b#exits [0 9 1 0]]
      [b#desc b#{This is room 8}]
++  , 9
    | tabFromPairs
    , [b#exits [0 13 2 8]]
      [b#desc b#{}]
++  , 10
    | tabFromPairs
    , [b#exits [14 0 11 2]]
      [b#desc b#{}]
++  , 11
    | tabFromPairs
    , [b#exits [10 0 12 5]]
      [b#desc b#{}]
++  , 12
    | tabFromPairs
    , [b#exits [11 0 0 0]]
      [b#desc b#{}]
++  , 13
    | tabFromPairs
    , [b#exits [0 14 2 9]]
      [b#desc b#{}]
++  , 14
    | tabFromPairs
    , [b#exits [0 0 10 13]]
      [b#desc b#{}]

= (maxRow x)
| foldl max (idx 0 x) x

= items
| tabFromPairs
++  , 1
    | tabFromPairs
    ,  [b#look b#{a rusty dagger}]
       [b#desc b#{it looks dull}]
++  , 2
    | tabFromPairs
    , [b#look (# b {a cheeseburger})]
      [b#desc (# b {it has a bite taken out of it})]
++  , 3
    | tabFromPairs
    , [b#look b#{a large stone}]
      [b#desc b#{there is some lichen on one side}]
++  , 4
    | tabFromPairs
    , [b#look (# b {a ruby})]
      [b#desc (# b {shiny})]
++  , 5
    | tabFromPairs
    , [b#look (# b {the thing you've been looking for})]
      [b#desc (# b {its not quite what you expected})]

= itemLocations
| tabFromPairs
++  , 1
    | tabFromPairs
    , [b#roomId 1]
      [b#playerId 0]
++  , 2
    | tabFromPairs
    , [b#roomId 2]
      [b#playerId 0]
++  , 3
    | tabFromPairs
    , [b#roomId 2]
      [b#playerId 0]
++  , 4
    | tabFromPairs
    , [b#roomId 3]
      [b#playerId 0]
++  , 5
    | tabFromPairs
    , [b#roomId 6]
      [b#playerId 0]

= playersT
| tabFromPairs
++  , 1
    | tabFromPairs
    , [b#connected 0]
      [b#name b#{Vinney}]
      [b#currentPosition 1]
      [b#hp 10]
++  , 2
    | tabFromPairs
    , [b#connected 0]
      [b#name b#{Chase}]
      [b#currentPosition 5]
      [b#hp 10]

; generateInitialState
= (gis)
| tabFromPairs
, [b#rooms rooms]
  [b#roomT rooms]
  [b#grid grid]
  [b#items items]
  [b#inventory []]
  [b#itemLocations itemLocations]
  [b#players playersT]
  [b#actingId 1]

= (movePlayer playerId moveTo state)
@ players | (tabGet state b#players)
@ player | tabGet players playerId
@ pMoved | tabIns b#currentPosition moveTo player
@ updPlayers | tabIns playerId pMoved players
| tabIns b#players updPlayers state

; Don't use this. poorly-conceived.
; TODO: Probably use Sets to do these "diffs" nicely
= (up change oldState)
@ key | (idx 0 change)
@ val | (idx 1 change)
; | trk [%key key %val val]
# switch key
* b#playerMove
  @ chgd | tabIns b#currentPosition val oldState
  ; | trk [%chngddddd chgd]
  chgd
* _
  oldState

= (stateGet key state)
| tabGet state key

= (roomGet id state)
| tabGet (stateGet b#rooms state) id

= (exitsGet roomId state)
| tabGet (roomGet roomId state) b#exits

= (itemGet id state)
| tabGet (stateGet b#items state) id

= (playerGet id state)
| tabGet (stateGet b#players state) id

= (curPos playerId state)
| tabGet (playerGet playerId state) b#currentPosition

= (curRoom playerId state)
| tabGet (stateGet b#roomT state) (curPos playerId state)

= (actingPlayerSet playerId state)
@ newState | tabIns b#actingId playerId state
[newState b#{}]

; = (getPlayerIds roomId state)
; | filter neq-0
; | map (filterByRoomId roomId)
; | tabToPairs
; | stateGet b#itemLocations state

; general purpose "get all x val in map" function
= (tabGetValsOfKey t key)
| listToRow
| listMap (x & (tabGet x key)) (tabValsList t)

= (itemLocationSetPlayer itemId playerId state)
@ oldLocs | stateGet b#itemLocations state
; | trk [%oldLocs oldLocs]
; @ oldItemLoc | tabGet oldLocs itemId
@ newItemLoc | tabFromPairs [[b#roomId 0] [b#playerId playerId]]
; | trk [%newItemLoc newItemLoc]
@ newLocs | tabIns itemId newItemLoc oldLocs
; | trk [%newLocs newLocs]
@ newState | tabIns b#itemLocations newLocs state
; | trk [%newState newState]
newState

= (itemLocationSetRoom itemId roomId state)
@ oldLocs | stateGet b#itemLocations state
; | trk [%oldLocs oldLocs]
; @ oldItemLoc | tabGet oldLocs itemId
@ newItemLoc | tabFromPairs [[b#playerId 0] [b#roomId roomId]]
; | trk [%newItemLoc newItemLoc]
@ newLocs | tabIns itemId newItemLoc oldLocs
; | trk [%newLocs newLocs]
@ newState | tabIns b#itemLocations newLocs state
; | trk [%newState newState]
newState

;= (itemLocationSetRoom itemId roomId state)
;0

= (flatten rows)
@ head (fromSome listHead rows)
@ tail (slice rows 1 (len rows))
| ifNot (len tail)
  head
| weld head (flatten tail)

= (flatGrid)
| flatten grid

; ++ [1 [0 0 3 0]]
; ++ [2 [0 2 4 0]]
; ++ [3 [0 0 5 0]]
; ++ [4 [1 4 0 0]]
; ++ [5 [0 5 6 3]]
; ++ [6 [4 0 0 0]]

= (dirIndex dir)
| if (eql dir b{n}) | 0
| if (eql dir b{e}) | 1
| if (eql dir b{s}) | 2
| if (eql dir b{w}) | 3
0

; returns room id
= (go playerId dir state)
| if (eql (curRoom playerId state) 0)
  | trk [%whereAreYou]
  0
@ nextRoom | get (tabGet (curRoom playerId state) b#exits) (dirIndex dir)
; | trk [%next nextRoom]
# switch nextRoom
* 0
  | curPos playerId state
* _
  nextRoom

; = (me tile currentPosition)
; | if (eql tile currentPosition)
;   b#{@}
; | natBar | showNat tile

= (printEntrance eRow)
  # switch (map (neq 0) eRow)
  * [1 1 1 1]
    b#{┼}
  * [0 1 1 1]
    b#{┬}
  * [1 1 0 1]
    b#{┴}
  * [1 1 1 0]
    b{├}
  * [1 0 1 1]
    b{┤}
  * [1 0 1 0]
    b{│}
  * [0 1 0 1]
    b{─}
  * [0 1 1 0]
    b{┌}
  * [0 0 1 1]
    b{┐}
  * [1 1 0 0]
    b{└}
  * [1 0 0 1]
    b{┘}
  * [1 0 0 0]
    b{╵}
  * [0 0 1 0]
    b{╷}
  * [0 0 0 1]
    b{╴}
  * [0 1 0 0]
    b{╶}
  b#{.}

= (printARoom playerId state roomId)
@ entrances | (tabGet (roomGet roomId state) b#exits)
| if (eql (curPos playerId state) roomId)
  b#{@}
| if (has roomId (tabGetValsOfKey (stateGet b#players state) b#currentPosition))
  b#{ɐ}
| if (len entrances)
  | printEntrance entrances
b#{#}

= (print playerId state message)
; @ rows | len grid
; @ cols | len (idx 0 grid)
@ gridRows | map (row & (barCat | map (roomId & printARoom playerId state roomId) row)) grid
@ rowLines | barCat | intersperse barNewline gridRows
@ result | barUnlines | intersperse barNewline [rowLines "" message "" b#{> }]
| trk [%map result]
result

=?= (dirIndex b{n})
  | 0

=?= (dirIndex b{e})
  | 1

=?= (dirIndex b{s})
  | 2

=?= (dirIndex b{w})
  | 3

=?= (dirIndex b{wut})
  | 0

=?= (curPos 1 gis)
  | 1

=?= 6
  @ s | movePlayer 1 4 gis
  | go 1 b{s} s

=?= 5
  @ players | (tabGet b#players gis)
  @ us | tabGet players 1
  @ usMoved | tabIns b#currentPosition 4 us
  @ updPlayers | tabIns 1 usMoved players
  @ s | tabIns b#players updPlayers gis
  | go 1 b{e} s

=?= 3
  @ players | (tabGet b#players gis)
  @ us | tabGet players 1
  @ usMoved | tabIns b#currentPosition 4 us
  @ updPlayers | tabIns 1 usMoved players
  @ s | tabIns b#players updPlayers gis
  | go 1 b{w} s

=?= 8
  @ players | (tabGet b#players gis)
  @ us | tabGet players 1
  @ usMoved | tabIns b#currentPosition 1 us
  @ updPlayers | tabIns 1 usMoved players
  @ s | tabIns b#players updPlayers gis
  | go 1 b{n} s

; this means going "x" actually goes north, because of dirIndex 0
=?= 7
  @ players | (tabGet b#players gis)
  @ us | tabGet players 1
  @ usMoved | tabIns b#currentPosition 4 us
  @ updPlayers | tabIns 1 usMoved players
  @ s | tabIns b#players updPlayers gis
  | go 1 b{x} s

; you're nowhere, can't go anywhere.
=?= 0
  @ players | (tabGet b#players gis)
  @ us | tabGet players 1
  @ usMoved | tabIns b#currentPosition 99 us
  @ updPlayers | tabIns 1 usMoved players
  @ s | tabIns b#players updPlayers gis
  | go 1 b{n} s

= (message playerId newState oldState dir)
| if (eql (curPos playerId newState) (curPos playerId oldState))
  | barCat [b#{** ouch **}]
| barCat [b#{** moved } dir b#{ **}]

= (invalid state)
[state b#{invalid command (h for help)}]

= (filterBy property value pair)
@ propInPair | tabGet (idx 1 pair) property
| if (eql value propInPair)
  (idx 0 pair)
0

= (filterByRoomId roomId pair)
| filterBy b#roomId roomId pair

= (filterByPlayerId playerId pair)
| filterBy b#playerId playerId pair

= (getItemIds roomId state)
| filter neq-0
| map (filterByRoomId roomId)
| tabToPairs
| stateGet b#itemLocations state

= (getInventoryIds playerId state)
| filter neq-0
| map (filterByPlayerId playerId)
| tabToPairs
| stateGet b#itemLocations state

= (getPlayerIds roomId state)
| filter neq-0
| map (filterBy b#currentPosition roomId)
| tabToPairs
| stateGet b#players state

= (filterItems itemIds state)
| tabFromPairs
| map (x & [x (tabGet (stateGet b#items state) x)]) itemIds

= (filterPlayers playerIds state)
| tabFromPairs
| map (x & [x (tabGet (stateGet b#players state) x)]) playerIds

; only get the 'look' of each item in an item map
= (itemLooks items)
| tabGetValsOfKey items b#look

; only get the 'name' of each player in a player map
= (playerNames playersT)
| tabGetValsOfKey playersT b#name

; Get an ID-prepended pairs list - for selecting by identifier
= (enumerateThings thingList)
; start at 1
@ ids | map inc | gen (len | thingList) id
| zip ids thingList

= (inventoryMsg playerId state)
@ itemIds | getInventoryIds playerId state
@ items | filterItems itemIds state
@ enumerated | enumerateThings | itemLooks items
@ printable | map (x & (barCat [(natBar | showNat (idx 0 x)) b#{ - } (idx 1 x)])) enumerated
@ itemPreamble |
               , b#{you are carrying:}
                 b#{}
                 b#{id   item}
                 b#{------------}
| if (len itemIds)
  | barCat | intersperse barNewline (cat [itemPreamble printable])
b#{your inventory is empty}

= (lookMsg playerId roomId state)
@ roomDesc | [(tabGet (roomGet roomId state) b#desc)]
@ otherPIds | filter (neq playerId) | getPlayerIds roomId state
@ players | filterPlayers otherPIds state
@ enumeratedPlayers | enumerateThings | playerNames players
; | trk [%ep enumeratedPlayers]
@ itemIds | getItemIds roomId state ; row of ids
@ items | filterItems itemIds state ; filtered map
@ enumerated | enumerateThings | itemLooks items
@ playerPreamble [b#{players here: }]
@ printablePlayers | map (x & (barCat [(natBar | showNat (idx 0 x)) b#{ - } (idx 1 x)])) enumeratedPlayers
@ printableEnumerated | map (x & (barCat [(natBar | showNat (idx 0 x)) b#{ - } (idx 1 x)])) enumerated
@ itemPreamble |
               , b#{things here:}
                 b#{}
                 b#{id   item}
                 b#{------------}
| if | and (len otherPIds) (len itemIds)
  | barCat | intersperse barNewline (cat [roomDesc playerPreamble printablePlayers b#{} itemPreamble printableEnumerated])
| if (len otherPIds)
  | barCat | intersperse barNewline (cat [roomDesc playerPreamble printablePlayers])
| if (len itemIds)
  | barCat | intersperse barNewline (cat [roomDesc itemPreamble printableEnumerated])
| barCat | intersperse barNewline (cat [roomDesc [b#{there is nothing here}]])

= (helpMsg state)
| barCat
| intersperse barNewline
  , b#{++ Command Help ++}
    b#{==================}
    b#{}
    b#{ - Help: h (this command)}
    b#{ - Moving: n e s w (to move north, east, south, west)}
    b#{ - Inventory: i (will return a list of things with ids for further interaction)}
    b#{ - Look Around: l (will return a list of things with ids for further interaction)}
    b#{ - Inspect Things: i <ID> (ID of thing from "look")}
    b#{ - Get Things: get <ID> (ID of thing from "look")}
    b#{ - Drop Things: drop <ID> (ID of thing from "inventory")}
    b#{ - Adore Your Things: a <ID> (ID of thing from "inventory")}
    b#{ - Impersonate: act <Player ID>}

= (handleSingleCmd playerId cmd state)
; | trk [%handlingSingle]
| if (has cmd [b#n b#e b#s b#w])
  ; | trk [%cmdState state]
  @ newRoomId | go playerId cmd state
  ; | trk [%rid newRoomId]
  @ newState | movePlayer playerId newRoomId state
  ; | trk [%newS newState]
  @ msg | barCat | intersperse barNewline [(message playerId newState state cmd) (lookMsg playerId newRoomId newState)]
  [newState msg]
| if (eql cmd b#{i})
  [state (inventoryMsg playerId state)]
| if (eql cmd b#{l})
  [state (lookMsg playerId (curPos playerId state) state)]
| if (eql cmd b#{h})
  ; | trk [%gettinghelp]
  [state (helpMsg state)]
| invalid state

= (getItemIdFromEnumerated enumeratedId roomId state)
; | trk [%gettingEnumerated enumeratedId]
@ itemIds | getItemIds roomId state
; | trk [%itemIds itemIds]
; the list of enuemrated items will always correspond to the items in the room:
| get itemIds (dec enumeratedId)

= (getInventoryIdFromEnumerated enumeratedId playerId state)
; | trk [%gettingEnumerated enumeratedId]
@ itemIds | getInventoryIds playerId state
; | trk [%itemIds itemIds]
; the list of enuemrated items will always correspond to the items in the inventory:
| get itemIds (dec enumeratedId)

=?= 3
  ; the second item in room 2
  | getItemIdFromEnumerated 2 2 gis

=?= 2
  ; the first item in room 2
  | getItemIdFromEnumerated 1 2 gis

=?= 1
  | getItemIdFromEnumerated 1 1 gis

= (takeItemId playerId enumeratedId roomId state)
@ itemId | getItemIdFromEnumerated enumeratedId roomId state
; | trk [%itemId itemId]
@ item | itemGet itemId state
@ newState | itemLocationSetPlayer itemId playerId state
@ nullMsg | b#{** that's not something to get **}
@ msg | barCat [b#{** you got } (tabGet item b#look) b#{ **}]
| if itemId
  [newState msg]
[newState nullMsg]

= (dropItemId playerId enumeratedId roomId state)
@ itemId | getInventoryIdFromEnumerated enumeratedId playerId state
; | trk [%itemId itemId]
@ item | itemGet itemId state
@ newState | itemLocationSetRoom itemId roomId state
@ nullMsg | b#{** that's not something to drop **}
@ msg | barCat [b#{** you dropped } (tabGet item b#look) b#{ **}]
| if itemId
  [newState msg]
[newState nullMsg]

= (inspectItem playerId enumeratedId roomId state)
@ itemId | getItemIdFromEnumerated enumeratedId playerId state
; | trk [%itemId itemId]
@ item | itemGet itemId state
@ nullMsg | b#{** that's not something to inspect **}
@ msg | barCat [b#{** inspecting } (tabGet item b#look) b#{: } (tabGet item b#desc)]
| if itemId
  [state msg]
[state nullMsg]

= (adoreItem playerId enumeratedId state)
@ itemId | getInventoryIdFromEnumerated enumeratedId playerId state
; | trk [%itemId itemId]
@ item | itemGet itemId state
@ nullMsg | b#{** that's not something to adore **}
@ msg | barCat [b#{** adoring } (tabGet item b#look) b#{: } (tabGet item b#desc)]
| if itemId
  [state msg]
[state nullMsg]

= (handleDuoCmd playerId cmd target state)
; | trk [%handlingDuo cmd target]
@ trgNat | fromSome 0 (parseNat (idx 0 target))
| if (eql cmd b#{act})
  | actingPlayerSet trgNat state
| if (eql cmd b#{get})
  | takeItemId playerId trgNat (curPos playerId state) state
| if (eql cmd b#{drop})
  | dropItemId playerId trgNat (curPos playerId state) state
| if (eql cmd b#{i})
  | inspectItem playerId trgNat (curPos playerId state) state
| if (eql cmd b#{a})
  | adoreItem playerId trgNat state
| invalid state

; return [state msg]
= (commandDo playerId input state)
; @ playerId | tabGet state b#actingId
; | trk [%cmdo input]
@ (cmd) | listToRow | barSplit { } | barTakeWhile (neq newlineChar) input
| if (eql 1 | len cmd)
* handleSingleCmd playerId (idx 0 cmd) state
* handleDuoCmd playerId (idx 0 cmd) (drop 1 cmd) state

> Pin Bar
= favicon
| PIN
| barCat
, x#{89504e470d0a1a0a0000000d4948445200000020000000200806000000737a7a}
  x#{f4000000017352474200aece1ce9000002a0494441545847ed563f486a71183d}
  x#{95e054439448e06063818b91e09fc616079186280c4402876875484b51281c5a}
  x#{1a1a1491a2a2c9c121684c88444187748a828230515c44a2a17c9c1ff4309ecf}
  x#{7bf53d5f6ff05b1cbcbf73ce3ddf77bedf1d02d0c437d6d040c0c081ffde81c9}
  x#{c949f87c3e919368348a42a1d031332a950a5eaf573cb3bfbf8fa7a7a78ecf4b}
  x#{a660787818cfcfcf50abd5d8ddddfd09fe3b54a7d389783c8e7abd0e8a7f7b7b}
  x#{fb33013c1d8bc5e072b990cbe5a0d7eb3b029e9f9f637979198944024b4b4b92}
  x#{1b46d20122d8ed7601d86c3631353585979797b6c00a8502e57219e3e3e34230}
  x#{9d902a590246474751a954a0542a418b8f8e8edae21a8d465c5f5fe3e3e34308}
  x#{a518a992258020979797585c5c042d5e5959698b1b0c06b1bdbd8d4c260383c1}
  x#{20c52dfe972d60737313070707a8d56ae0a4bfbfbfff4290cd66313737879d9d}
  x#{1d8442a1bf2b607a7a1af7f7f7029456dfdcdc7c21a0a852a904a68683ca8195}
  x#{53b21d2058b158c4cccc8c783bbe656badadade1f8f8584456a3d1888195535d}
  x#{090887c3f0783ca0d5f3f3f35ff04f4f4fb1baba8a482402b7db2d87bbbb19e0}
  x#{d30b0b0bb8baba1253cec5c464b0464646443427262660b3d9904c26fb23a035}
  x#{e7b4fce4e4441071e2d3e9345e5f5fc5f66b341afd1140d44fabf9eb70380491}
  x#{dfef472010c0c5c505ac56ab6cf2ae62f889ca3e939cf6b30d6c07df9e2e6c6c}
  x#{6ce0f0f0b0bf02b866b9e1d80e923e3c3c88fe337e5aad168f8f8ffd1540f454}
  x#{2a058bc522acbfbbbbc3d9d9196e6f6fa1d3e9ba22efa9053cc4283292b49e02}
  x#{38907b7b7bd8dadafa3702666767c58709d731277e6c6c0c66b3595c44dd5657}
  x#{8ba8159cbd67cf59d56a550c64bbfb414a50cf02d6d7d7613299047e3e9f1717}
  x#{552fd5b3805ec8da9d19081838f0ed0efc0071b51f10d1add5a6000000004945}
  x#{4e44ae426082}

# typedef ContentType Bar

> HMap Str (ContentType, Pin Bar)
= startingFiles
| hmSingleton
* largeConfig
* {/favicon.ico}
* [b#{image/x-icon} favicon]

# record CogState
| COG_STATE
* mudState   : Map
* epoch      : Nat
* files      : (HMap Str (ContentType, Pin Bar))
* servThread : ThreadId

> ThreadId > CogState
= (newCogState servThread)
| COG_STATE
* gis
* 1
* startingFiles
* servThread

(emptyFileServer req)=NONE

= (fileServer (PIN st) [method path headers (PIN body)])
| trk [%fileServerRequest method path headers body]
;@ originHeader | **fromSome b#{localhost}
;               | tabLookup b#{origin}
;               | tabFromPairs headers
;@ head | dynamicCors originHeader
# switch method
* _ | NONE
* GET
  | **fmapMaybe | hmLookup (barNat path) (**getFiles st)
  & [type (PIN content)]
  @ head | [(b#{Content-Type}, type)]
  [200 b#gotcha head content]

= (modifyState vSt fun return)
: (PIN old) < readRef vSt
@ srv       | **getServThread old
@ pNew      | PIN (fun old)
: _         < writeRef vSt pNew
: _         < cancelFork srv (syscall (**HTTP_SERV | fileServer pNew))
| return ()

(bindMaybe mVal k)=(maybeCase mVal NONE k)

> Bar > Maybe (Tab Str Json)
= (jsonMap jsonBS)
@ res@[json leftover] (parseJson jsonBS)
| if (res || leftover) NONE
# datacase json
* JMAP|m | SOME m
* _      | NONE

= (asJsonStr m)
# datacase m
* JSTR|s | SOME s
* _      | NONE

= (asJsonNum m)
# datacase m
* JNUM|n | SOME n
* _      | NONE

= (parseCommandJson jsonBS)
: map < **bindMaybe (jsonMap jsonBS)
: cmd < **bindMaybe (tabLookup %cmd map)
: cmS < **bindMaybe (asJsonStr cmd)
| cmS

= (parseWhoJson jsonBS)
: map < **bindMaybe (jsonMap jsonBS)
: who < **bindMaybe (tabLookup %who map)
who

= (dynamicCors origin)
[(b#{Access-Control-Allow-Origin}, origin) (b#{Content-Type}, b#{application/json}) (b#{Access-Control-Allow-Credentials}, b#{true}) (b#{Access-Control-Allow-Headers}, b#{Content-Type, Authorization}) (b#{Access-Control-Allow-Methods}, b#{POST, GET, PUT, OPTIONS})]

= (buildJson st)
@ COG_STATE(..) st
| JMAP
## =who | JVEC (tabGet (getMudState st) b#players) ; row-in-row for some reason

= (handleReq vSt request return)
@ [rid method path headers pBody@(PIN body)] request
| trk [%handleReq request]
@ originHeader | **fromSome b#{localhost}
               | tabLookup b#{origin}
               | tabFromPairs headers
@ head | dynamicCors originHeader
# switch method
* GET
  # switch path
  * b#{/world}
    : (PIN st) < readRef vSt
    | trk [%print (print 1 (getMudState st) [])] ; TODO: player ID
    : _ < fork (syscall (**HTTP_ECHO rid 200 b#ok head b#{}))
    | return ()
  * b#{/who}
    : (PIN st) < readRef vSt
    ; TODO: fix json:
    @ whoJson   | **buildJson st
    @ whoJsonBS | printJson whoJson
    : _ < fork (syscall (**HTTP_ECHO rid 200 b#ok head whoJsonBS))
    | return ()
  * _
    : _ < fork (syscall (**HTTP_ECHO rid 400 b#bad head b#{}))
    | return ()
* POST
  # switch path
  * b#{/cmd}
    : (PIN st) < readRef vSt
    @ gameState | getMudState st
    | trk [%body body]
    @ input    | parseCommandJson body
    @ playerId | fromSome 1 (parseNat | parseWhoJson body)
    | trk [%playerId playerId]
    @ [changed msg] | commandDo playerId input gameState
    : _ < modifyState vSt & st
                          | setMudState | changed
                          | st
    | trk [%print (print playerId changed msg)]
    @ worldBytes (print playerId changed msg)
    ; take a command, update the state, respond with print
    : _ < fork (syscall (**HTTP_ECHO rid 200 b#ok head worldBytes))
    | return ()
  * _
    : _ < fork (syscall (**HTTP_ECHO rid 400 b#bad head b#{}))
    | return ()
* PUT
  : (PIN st) < readRef vSt
  @ barType | **fromSome b#{text/plain}
            | tabLookup b#{content-type}
            | tabFromPairs headers
  @ files (**getFiles st)
  @ files | hmInsert (barNat path) [barType pBody] files
  : _ < fork (syscall (**HTTP_ECHO rid 201 b#done [] b#{}))
  : _ < modifyState vSt & st
                        | setFiles files
                        | st
  | return ()
* OPTIONS
  : _ < fork (syscall (**HTTP_ECHO rid 200 b#ok head b#{}))
  | return ()
* _
  | trk [%gotUnknown method]
  : _ < fork (syscall (**HTTP_ECHO rid 400 b#bad [] b#{}))
  | return ()


= (runHttpServer vSt return)
: ??(rhs_heard req) < syscall HTTP_HEAR
: _                 < handleReq vSt req
| runHttpServer vSt return

= (tick vSt return)
: (PIN pinState) < readRef vSt
@ epoch | getEpoch pinState
: ??(td_got_time now) < syscall TIME_WHEN
; | trk [current_time=now]
: ??(td_waited _) < syscall (**TIME_WAIT | inc now)
; TODO: need to do all the in-game state editing
; @ newState | pinState
; @ input | b#{s\n} ; TODO: fake.
; @ [changed msg] | commandDo input newState
; @ newState | changed
; @ playerId | tabGet changed b#actingId
; | (print playerId newState msg, tick newState return)
;
; : _ < modifyState vSt | setEpoch | inc epoch
;
: _ < modifyState vSt & pinState
                      | setEpoch | inc epoch
                      | pinState
| tick vSt return

= (spinMud return)
: servThread  < fork (syscall (**HTTP_SERV emptyFileServer))
: vSt         < newRef (PIN | newCogState servThread)
: timerThread < fork (tick vSt)
: httpThread1 < fork (runHttpServer vSt)
: httpThread2 < fork (runHttpServer vSt)
| return ()

main=(runCog spinMud)
