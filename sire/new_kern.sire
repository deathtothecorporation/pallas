#### new_kern <- prelude

:| prelude

= (EVAL f as)            [0 f as]
= (EXEC pump)            [1 pump]

= (DB_READ query)        [0 %read query]
= (DB_WRITE cmd)         [0 %write cmd]
= TIME_WHEN              [%time %when]
= (TIME_WAIT ns)         [%time %wait ns]
= (HTTP_REQ m u h b r t) [%http %req m u h b r t]
= (HTTP_SERV ss)         [%http %serv ss]
= (HTTP_HEAR)            [%http %hear]
= (HTTP_HOLD n)          [%http %hold n]
= (HTTP_ECHO r c m h b)  [%http %echo r c m h b]

= (syscall request k end nx sl rq)
@ rq | rowCons (nx,request) rq
@ sl | rowSnoc sl k
@ nx | inc nx
| end nx sl rq

= (COG_KERNEL st rs ws inputs)
'cog_kernel

= (PUMP_KERNEL nx sl rq key input)
@ exe | get sl key
@ sl  | put sl key 0
@ rq  | []                 ; TODO This should be solved in the runtime
| ifz exe | PUMP_KERNEL nx sl rq
@ end | PUMP_KERNEL
| exe input end nx sl rq

= (COG_DONE _ end st rs ws)
| end st rs ws

= (PUMP_DONE _ end nx sl rq)
| end nx sl rq

= (work [mode worker] cogK cogEnd st rs ws)
@ k   | PUMP_DONE
@ end | PUMP_KERNEL
@ nx  | 0
@ sl  | []
@ rq  | []
@ w   | worker k end nx sl rq
@ newWs | rowSnoc ws [mode w]
| cogK len-ws cogEnd st rs newWs

= (runCog cog)
@ k   | COG_DONE
@ end | COG_KERNEL
@ st  | 0
@ rs  | (_ _ _ & 0)
@ ws  | []
| cog COG_DONE COG_KERNEL st rs ws
