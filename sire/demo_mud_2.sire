#### demo_mud_2 <- prelude

; stack run plunder save mud.seed sire/demo_mud_2.sire
; stack run plunder repl mud.seed

:| sire

;172;
;345;
;060;

= grid
, [1 7 2]
  [3 4 5]
  [0 6 0]

;= r [1  0 0 3 0]
;;    id n e s w
; TODO: change to a Tab (exits, items, description, creatures, etc)
= rooms
, [1 0 7 3 0 [b#{a rusty dagger} b#{3 coins}]]     ;1
  [2 0 0 5 7 [b#{a human skull made of tin foil}]] ;2
  [3 1 4 0 0 [b#{footprints...} b#{detritus}]]
  [4 7 5 6 3 [b#{many pinholes in the  walls} b#{tiny worms writhing on the ground}]]
  [5 2 0 0 4 []]
  [6 4 0 0 0 [b#{yourself, standing on the ceiling}]]
  [7 0 2 4 1 [b#{a wide open space}]] ; 7

= roomPairs | map (x & [(fromSome listHead x) (slice x 1 (len x))]) rooms
= roomT | tabFromPairs roomPairs

; TODO: allow for defining rooms, items, etc. all state in a separate file
;       that gets ingested here.

; TODO: have a separate items key in the state with unique IDs
;       use these as entries in the rooms items list.
; generateInitialState
= (gis)
@ stats | tabFromPairs
        , [b#hp 10]
          [b#todo 100]
| tabFromPairs
, [b#rooms rooms]
  [b#roomT roomT]
  [b#grid grid]
  [b#currentPosition 1]
  [b#inventory []]
  [b#stats stats]

; TODO: Probably use Sets to do these "diffs" nicely
= (up change oldState)
@ key | (idx 0 change)
@ val | (idx 1 change)
| trk [%key key %val val]
# switch key
* b#playerMove
  @ chgd | tabIns b#currentPosition val oldState
  | trk [%chngddddd chgd]
  chgd
* _
  oldState

= (stateGet key state)
| tabGet state key

= (curPos state)
| stateGet b#currentPosition state

= (curRoom state)
| tabGet (stateGet b#roomT state) (curPos state)


= (flatten rows)
@ head (fromSome listHead rows)
@ tail (slice rows 1 (len rows))
| ifNot (len tail)
  head
| weld head (flatten tail)

= (flatGrid)
| flatten grid

; ++ [1 [0 0 3 0]]
; ++ [2 [0 2 4 0]]
; ++ [3 [0 0 5 0]]
; ++ [4 [1 4 0 0]]
; ++ [5 [0 5 6 3]]
; ++ [6 [4 0 0 0]]

= (dirIndex dir)
| if (eql dir b{n}) | 0
| if (eql dir b{e}) | 1
| if (eql dir b{s}) | 2
| if (eql dir b{w}) | 3
0

; returns room id
= (go dir state)
@ ourRoom | curRoom state
| trk [%our ourRoom]
| if (eql ourRoom 0)
  | trk [%whereAreYou]
  0
@ nextRoom | get ourRoom | dirIndex dir
# switch nextRoom
* 0
  | curPos state
* _
  nextRoom

; = (me tile currentPosition)
; | if (eql tile currentPosition)
;   b#{@}
; | natBar | showNat tile

= (printEntrance eRow)
  # switch (map (neq 0) eRow)
  * [1 1 1 1]
    b#{┼}
  * [0 1 1 1]
    b#{┬}
  * [1 1 0 1]
    b#{┴}
  * [1 1 1 0]
    b{├}
  * [1 0 1 1]
    b{┤}
  * [1 0 1 0]
    b{│}
  * [0 1 0 1]
    b{─}
  * [0 1 1 0]
    b{┌}
  * [0 0 1 1]
    b{┐}
  * [1 1 0 0]
    b{└}
  * [1 0 0 1]
    b{┘}
  * [1 0 0 0]
    b{╵}
  * [0 0 1 0]
    b{╷}
  * [0 0 0 1]
    b{╴}
  * [0 1 0 0]
    b{╶}
  b#{.}

= (printARoom state roomId)
@ entrances | take 4 | tabGet roomT roomId
| if (eql (curPos state) roomId)
  b#{@}
| if (len entrances)
  | printEntrance entrances
b#{#}

; TODO: show current player position
= (print state message)
@ roomz | map (x & tabGet roomT x) flatGrid
@ top | barCat | map (roomId & printARoom state roomId) (slice flatGrid 0 3)
@ mid | barCat | map (roomId & printARoom state roomId) (slice flatGrid 3 6)
@ bot | barCat | map (roomId & printARoom state roomId) (slice flatGrid 6 9)
| barUnlines | intersperse barNewline [top mid bot "" message "" b#{> }]

=?= (dirIndex b{n})
  | 0

=?= (dirIndex b{e})
  | 1

=?= (dirIndex b{s})
  | 2

=?= (dirIndex b{w})
  | 3

=?= (dirIndex b{wut})
  | 0

=?= (curPos gis)
  | 1

=?= (curRoom gis)
  | [0 7 3 0 [b#{a rusty dagger} b#{3 coins}]]

=?= 6
  @ s | tabIns b#currentPosition 4 gis
  | go b{s} s

=?= 5
  @ s | tabIns b#currentPosition 4 gis
  | go b{e} s

=?= 3
  @ s | tabIns b#currentPosition 4 gis
  | go b{w} s

=?= 1
  @ s | tabIns b#currentPosition 1 gis
  | go b{n} s

; TODO: this means going "x" actually goes north, because of dirIndex 0
=?= 7
  @ s | tabIns b#currentPosition 4 gis
  | go b{x} s

=?= 0
  @ s | tabIns b#currentPosition 9 gis
  | go b{n} s

= (message newState oldState dir)
| if (eql (tabGet newState b#currentPosition) (tabGet oldState b#currentPosition))
  b#ouch
| barCat [b#{moved } dir]

= (invalid state)
[state b#{invalid command (n e s w l {get <id>})}]

= (lookMsg state)
@ items | idx 4 | tabGet roomT (curPos state)
| if (len items)
  | barCat | intersperse barNewline [b#{you see: } (barCat | intersperse barNewline items)]
b#{there is nothing here}


> Bar > Nat > (Nat, Bar)
= (handleSingleCmd cmd state)
| if (has cmd [b#n b#e b#s b#w])
  | trk [%cmdState state]
  @ newRoomId | go cmd state
  | trk [%rid newRoomId]
  @ newState | up [b#playerMove newRoomId] state
  | trk [%newS newState]
  @ msg | barCat | intersperse barNewline [(message newState state cmd) (lookMsg newState)]
  [newState msg]
| if (eql cmd b#{l})
  ; TODO:
  [state (lookMsg state)]
| invalid state


= (handleDuoCmd cmd target state)
| if (eql cmd b#{get})
  ; TODO:
  [state (barCat [b#{you get } (barCat | target)]) ]
| invalid state

; return state
= (commandDo input state)
@ (cmd) | listToRow | barSplit { } | barTakeWhile (neq newlineChar) input ; when seeding
| if (eql 1 | len cmd)
* handleSingleCmd (idx 0 cmd) state
* handleDuoCmd (idx 0 cmd) (drop 1 cmd) state

= (tick state input)
@ [changed msg] | commandDo input state
| trk [%changed changed]
@ newState | changed
; @ newPosition | go dir currentPosition
; @ msg | message currentPosition newPosition dir
| (print newState msg, tick newState)

print 1 (barUnlines b{welcome. move with any of n e s w followed by <enter>})
= main | tick gis

; = (showTodo todo)
; ^ barWeld _ barNewline
; | barIntercalateList barNewline
; : (done,name) < listForEach todo
; ^ barWeld _ name
; | if done
; * b#{[x] }
; * b#{[ ] }
; 
; = (addItem name todo)
; | listNub ((FALSE,name) :: todo)
; 
; = (deleteItem name todo)
; | listFilter (_,n)&(n /= name) todo
; 
; = (doneItem name todo)
; : (done,n) < listForEach todo
; | (done || n==name, n)
; 
; = (step state input)
; @ (cmd, item) | barSplitOne { } | barTakeWhile (neq newlineChar) input
; # switch cmd
; * b#add
;   @ state | addItem item state
;   | (showTodo state, step state)
; * b#del
;   @ state | deleteItem item state
;   | (showTodo state, step state)
; * b#done
;   @ state | doneItem item state
;   | (showTodo state, step state)
; * b#show
;   | (showTodo state, step state)
; * _
;   ^ (_, step state)
;   | barCat [(showTodo state) barNewline b#{Invalid command: } input]
; 
; = main | step ~[]

