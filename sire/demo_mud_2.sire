#### demo_mud_2 <- prelude

; stack run plunder save mud.seed sire/demo_mud_2.sire
; stack run plunder repl mud.seed

:| sire

;172;
;345;
;060;

; TODO / IDEAS
; - generate stuff in rooms from random tables
;   - then add AI...

= grid
, [1 7 2]
  [3 4 5]
  [0 6 0]

;= r [1  0 0 3 0]
;;    id n e s w
; TODO: change to a Tab (exits, items, description, creatures, etc)
= rooms
, [1 0 7 3 0 [b#{a rusty dagger} b#{3 coins}]]     ;1
  [2 0 0 5 7 [b#{a human skull made of tin foil}]] ;2
  [3 1 4 0 0 [b#{footprints...} b#{detritus}]]
  [4 7 5 6 3 [b#{many pinholes in the  walls} b#{tiny worms writhing on the ground}]]
  [5 2 0 0 4 []]
  [6 4 0 0 0 [b#{yourself, standing on the ceiling}]]
  [7 0 2 4 1 [b#{a wide open space}]] ; 7

; TODO: add room description
= rooms
| tabFromPairs
++  , 1
    | tabFromPairs
    , [b#exits [0 7 3 0]]
++  , 2
    | tabFromPairs
    , [b#exits [0 0 5 7]]
++  , 3
    | tabFromPairs
    , [b#exits [1 4 0 0]]
++  , 4
    | tabFromPairs
    , [b#exits [7 5 6 3]]
++  , 5
    | tabFromPairs
    , [b#exits [2 0 0 4]]
++  , 6
    | tabFromPairs
    , [b#exits [4 0 0 0]]
++  , 7
    | tabFromPairs
    , [b#exits [0 2 4 1]]

= (maxRow x)
| foldl max (idx 0 x) x

= items
| tabFromPairs
++  , 1
    | tabFromPairs
    ,  [b#look b#{a rusty dagger}]
       [b#desc b#{it looks dull}]
++  , 2
    | tabFromPairs
    , [b#look (# b {a cheeseburger})]
      [b#desc (# b {it has a bite taken out of it})]
++  , 3
    | tabFromPairs
    , [b#look b#{a large stone}]
      [b#desc b#{there is some lichen on one side}]
++  , 4
    | tabFromPairs
    , [b#look (# b {a ruby})]
      [b#desc (# b {shiny})]
++  , 5
    | tabFromPairs
    , [b#look (# b {the thing you've been looking for})]
      [b#desc (# b {its not quite what you expected})]

= itemLocations
| tabFromPairs
++  , 1
    | tabFromPairs
    , [b#roomId 1]
      [b#playerId 0]
++  , 2
    | tabFromPairs
    , [b#roomId 2]
      [b#playerId 0]
++  , 3
    | tabFromPairs
    , [b#roomId 2]
      [b#playerId 0]
++  , 4
    | tabFromPairs
    , [b#roomId 3]
      [b#playerId 0]
++  , 5
    | tabFromPairs
    , [b#roomId 6]
      [b#playerId 0]

= playersT
| tabFromPairs
++  , 1
    | tabFromPairs
    , [b#connected 0]
      [b#name b#{Vinney}]
      [b#currentPosition 1]
      [b#hp 10]
++  , 2
    | tabFromPairs
    , [b#connected 0]
      [b#name b#{Chase}]
      [b#currentPosition 5]
      [b#hp 10]

; TODO: allow for defining rooms, items, etc. all state in a separate file
;       that gets ingested here.

; generateInitialState
= (gis)
| tabFromPairs
, [b#rooms rooms]
  [b#roomT rooms]
  [b#grid grid]
  [b#items items]
  [b#inventory []]
  [b#itemLocations itemLocations]
  [b#players playersT]

= (movePlayer playerId moveTo state)
@ players | (tabGet state b#players)
| trk [%players players]
@ player | tabGet players playerId
| trk [%player player]
@ pMoved | tabIns b#currentPosition moveTo player
| trk [%pMoved pMoved]
@ updPlayers | tabIns playerId pMoved players
| trk [%updPlayers updPlayers]
; @ updPlayers | tabIns playerId pMoved players
| tabIns b#players updPlayers state

; TODO: Probably use Sets to do these "diffs" nicely
= (up change oldState)
@ key | (idx 0 change)
@ val | (idx 1 change)
| trk [%key key %val val]
# switch key
* b#playerMove
  @ chgd | tabIns b#currentPosition val oldState
  | trk [%chngddddd chgd]
  chgd
* _
  oldState

= (stateGet key state)
| tabGet state key

= (roomGet id state)
| tabGet (stateGet b#rooms state) id

= (exitsGet roomId state)
| tabGet (roomGet roomId state) b#exits

= (itemGet id state)
| tabGet (stateGet b#items state) id

= (playerGet id state)
| tabGet (stateGet b#players state) id

= (curPos playerId state)
| tabGet (playerGet playerId state) b#currentPosition

= (curRoom playerId state)
| tabGet (stateGet b#roomT state) (curPos playerId state)

; = (getPlayerIds roomId state)
; | filter neq-0
; | map (filterByRoomId roomId)
; | tabToPairs
; | stateGet b#itemLocations state

; general purpose "get all x val in map" function
> Tab > Row
= (tabGetValsOfKey t key)
| listToRow
| listMap (x & (tabGet x key)) (tabValsList t)

= (itemLocationSetPlayer itemId playerId state)
@ oldLocs | stateGet b#itemLocations state
| trk [%oldLocs oldLocs]
; @ oldItemLoc | tabGet oldLocs itemId
@ newItemLoc | tabFromPairs [[b#roomId 0] [b#playerId playerId]]
| trk [%newItemLoc newItemLoc]
@ newLocs | tabIns itemId newItemLoc oldLocs
| trk [%newLocs newLocs]
@ newState | tabIns b#itemLocations newLocs state
| trk [%newState newState]
newState

;= (itemLocationSetRoom itemId roomId state)
;0

= (flatten rows)
@ head (fromSome listHead rows)
@ tail (slice rows 1 (len rows))
| ifNot (len tail)
  head
| weld head (flatten tail)

= (flatGrid)
| flatten grid

; ++ [1 [0 0 3 0]]
; ++ [2 [0 2 4 0]]
; ++ [3 [0 0 5 0]]
; ++ [4 [1 4 0 0]]
; ++ [5 [0 5 6 3]]
; ++ [6 [4 0 0 0]]

= (dirIndex dir)
| if (eql dir b{n}) | 0
| if (eql dir b{e}) | 1
| if (eql dir b{s}) | 2
| if (eql dir b{w}) | 3
0

; returns room id
= (go playerId dir state)
| if (eql (curRoom playerId state) 0)
  | trk [%whereAreYou]
  0
@ nextRoom | get (tabGet (curRoom playerId state) b#exits) (dirIndex dir)
| trk [%next nextRoom]
# switch nextRoom
* 0
  | curPos playerId state
* _
  nextRoom

; = (me tile currentPosition)
; | if (eql tile currentPosition)
;   b#{@}
; | natBar | showNat tile

= (printEntrance eRow)
  # switch (map (neq 0) eRow)
  * [1 1 1 1]
    b#{┼}
  * [0 1 1 1]
    b#{┬}
  * [1 1 0 1]
    b#{┴}
  * [1 1 1 0]
    b{├}
  * [1 0 1 1]
    b{┤}
  * [1 0 1 0]
    b{│}
  * [0 1 0 1]
    b{─}
  * [0 1 1 0]
    b{┌}
  * [0 0 1 1]
    b{┐}
  * [1 1 0 0]
    b{└}
  * [1 0 0 1]
    b{┘}
  * [1 0 0 0]
    b{╵}
  * [0 0 1 0]
    b{╷}
  * [0 0 0 1]
    b{╴}
  * [0 1 0 0]
    b{╶}
  b#{.}

= (printARoom playerId state roomId)
@ entrances | (tabGet (roomGet roomId state) b#exits)
| if (eql (curPos playerId state) roomId)
  b#{@}
| if (has roomId (tabGetValsOfKey (stateGet b#players state) b#currentPosition))
  b#{ɐ}
| if (len entrances)
  | printEntrance entrances
b#{#}

= (print playerId state message)
@ top | barCat | map (roomId & printARoom playerId state roomId) (slice flatGrid 0 3)
@ mid | barCat | map (roomId & printARoom playerId state roomId) (slice flatGrid 3 6)
@ bot | barCat | map (roomId & printARoom playerId state roomId) (slice flatGrid 6 9)
| barUnlines | intersperse barNewline [top mid bot "" message "" b#{> }]

=?= (dirIndex b{n})
  | 0

=?= (dirIndex b{e})
  | 1

=?= (dirIndex b{s})
  | 2

=?= (dirIndex b{w})
  | 3

=?= (dirIndex b{wut})
  | 0

=?= (curPos 1 gis)
  | 1

=?= 6
  @ s | movePlayer 1 4 gis
  | go 1 b{s} s

=?= 5
  @ players | (tabGet b#players gis)
  @ us | tabGet players 1
  @ usMoved | tabIns b#currentPosition 4 us
  @ updPlayers | tabIns 1 usMoved players
  @ s | tabIns b#players updPlayers gis
  | go 1 b{e} s

=?= 3
  @ players | (tabGet b#players gis)
  @ us | tabGet players 1
  @ usMoved | tabIns b#currentPosition 4 us
  @ updPlayers | tabIns 1 usMoved players
  @ s | tabIns b#players updPlayers gis
  | go 1 b{w} s

=?= 1
  @ players | (tabGet b#players gis)
  @ us | tabGet players 1
  @ usMoved | tabIns b#currentPosition 1 us
  @ updPlayers | tabIns 1 usMoved players
  @ s | tabIns b#players updPlayers gis
  | go 1 b{n} s

; TODO: this means going "x" actually goes north, because of dirIndex 0
=?= 7
  @ players | (tabGet b#players gis)
  @ us | tabGet players 1
  @ usMoved | tabIns b#currentPosition 4 us
  @ updPlayers | tabIns 1 usMoved players
  @ s | tabIns b#players updPlayers gis
  | go 1 b{x} s

; you're nowhere, can't go anywhere.
=?= 0
  @ players | (tabGet b#players gis)
  @ us | tabGet players 1
  @ usMoved | tabIns b#currentPosition 9 us
  @ updPlayers | tabIns 1 usMoved players
  @ s | tabIns b#players updPlayers gis
  | go 1 b{n} s

= (message playerId newState oldState dir)
| if (eql (curPos playerId newState) (curPos playerId oldState))
  b#ouch
| barCat [b#{moved } dir]

= (invalid state)
[state b#{invalid command (h for help)}]

= (filterBy property value pair)
@ propInPair | tabGet (idx 1 pair) property
| if (eql value propInPair)
  (idx 0 pair)
0

= (filterByRoomId roomId pair)
| filterBy b#roomId roomId pair

= (getItemIds roomId state)
| filter neq-0
| map (filterByRoomId roomId)
| tabToPairs
| stateGet b#itemLocations state

= (getPlayerIds roomId state)
| filter neq-0
| map (filterBy b#currentPosition roomId)
| tabToPairs
| stateGet b#players state

= (filterItems itemIds state)
| tabFromPairs
| map (x & [x (tabGet (stateGet b#items state) x)]) itemIds

= (filterPlayers playerIds state)
| tabFromPairs
| map (x & [x (tabGet (stateGet b#players state) x)]) playerIds

; only get the 'look' of each item in an item map
> Tab > Row
= (itemLooks items)
| tabGetValsOfKey items b#look

; only get the 'name' of each player in a player map
> Tab > Row
= (playerNames playersT)
| tabGetValsOfKey playersT b#name

; Get an ID-prepended pairs list - for selecting by identifier
> List > Row Pairs
= (enumerateThings thingList)
; start at 1
@ ids | map inc | gen (len | thingList) id
| zip ids thingList

; TODO: Add room description
= (lookMsg playerId roomId state)
@ otherPIds | filter (neq playerId) | getPlayerIds roomId state
@ players | filterPlayers otherPIds state
@ enumeratedPlayers | enumerateThings | playerNames players
| trk [%ep enumeratedPlayers]
@ itemIds | getItemIds roomId state ; row of ids
@ items | filterItems itemIds state ; filtered map
@ enumerated | enumerateThings | itemLooks items
@ playerPreamble [b#{players here: }]
@ printablePlayers | map (x & (barCat [(natBar | showNat (idx 0 x)) b#{ - } (idx 1 x)])) enumeratedPlayers
@ printableEnumerated | map (x & (barCat [(natBar | showNat (idx 0 x)) b#{ - } (idx 1 x)])) enumerated
@ itemPreamble |
               , b#{things here:}
                 b#{}
                 b#{id   item}
                 b#{------------}
| if | and (len otherPIds) (len itemIds)
  | barCat | intersperse barNewline (cat [playerPreamble printablePlayers b#{} itemPreamble printableEnumerated])
| if (len otherPIds)
  | barCat | intersperse barNewline (cat [playerPreamble printablePlayers])
| if (len itemIds)
  | barCat | intersperse barNewline (cat [itemPreamble printableEnumerated])
b#{there is nothing here}

= (helpMsg state)
| barCat
| intersperse barNewline
  , b#{++ Command Help ++}
    b#{==================}
    b#{}
    b#{ - Help: h (this command)}
    b#{ - Moving: n e s w (to move north, east, south, west)}
    b#{ - Inventory: i (will return a list of things with ids for further interaction}
    b#{ - Look Around: l (will return a list of things with ids for further interaction}
    b#{ - Inspect Things: i <ID> (ID of thing from "look")}
    b#{ - Get Things: get <ID> (ID of thing from "look")}

> Bar > Nat > (Nat, Bar)
= (handleSingleCmd playerId cmd state)
| trk [%handlingSingle]
| if (has cmd [b#n b#e b#s b#w])
  | trk [%cmdState state]
  @ newRoomId | go playerId cmd state
  | trk [%rid newRoomId]
  @ newState | movePlayer playerId newRoomId state
  | trk [%newS newState]
  @ msg | barCat | intersperse barNewline [(message playerId newState state cmd) (lookMsg playerId newRoomId newState)]
  [newState msg]
| if (eql cmd b#{i})
  [state (inventory playerId state)]
| if (eql cmd b#{l})
  [state (lookMsg playerId (curPos playerId state) state)]
| if (eql cmd b#{h})
  | trk [%gettinghelp]
  [state (helpMsg state)]
| invalid state

= (getItemIdFromEnumerated enumeratedId roomId state)
@ itemIds | getItemIds roomId state
| get itemIds (dec enumeratedId)
; identify which item id this id denotes
;   - see what transient IDs come out of enumeration
;   - derive actual item ID from this

=?= 3
  ; the second item in room 2
  | getItemIdFromEnumerated 2 2 gis

=?= 2
  ; the first item in room 2
  | getItemIdFromEnumerated 1 2 gis

=?= 1
  | getItemIdFromEnumerated 1 1 gis

; TODO: its always getting id 1!
; given a room id and an enumerated item id, pick up that item.
> PlayerId > EnumID > RoomID > State > (State, Msg)
= (takeItemId playerId enumeratedId roomId state)
@ itemId | getItemIdFromEnumerated enumeratedId roomId state
| trk [%itemId itemId]
@ item | itemGet itemId state
@ newState | itemLocationSetPlayer itemId playerId state
@ msg | barCat [b#{you got } (tabGet item b#look)]
[newState msg]

; TODO
; given a room id and an enumerated inventory id, drop up that item.
> PlayerId > EnumID > RoomID > State > (State, Msg)
= (dropItemId playerId enumeratedId roomId state)
;@ itemId | getItemIdFromEnumerated enumeratedId roomId state
;@ item | itemGet itemId state
;@ newState | itemLocationSetPlayer itemId playerId state
;@ msg | barCat [b#{you got } (tabGet item b#look)]
;[newState msg]
0

= (handleDuoCmd playerId cmd target state)
| trk [%handlingDuo]
| if (eql cmd b#{i})
  ; TODO:
  [state (barCat [b#{you inspect } (barCat | target)]) ]
| if (eql cmd b#{get})
  ; TODO:
  | takeItemId playerId target (curPos playerId state) state
| invalid state

; return [state msg]
> PlayerID > Input > State > (State, Message)
= (commandDo playerId input state)
| trk [%cmdo input playerId]
@ (cmd) | listToRow | barSplit { } | barTakeWhile (neq newlineChar) input ; when seeding
| if (eql 1 | len cmd)
* handleSingleCmd playerId (idx 0 cmd) state
* handleDuoCmd playerId (idx 0 cmd) (drop 1 cmd) state

; TODO:
; tick should not have player ID.
; tick should just emanate all the state out. right now it only happens
; in response to commands, but it should be adjusted for game loop timer.
; this should be a general purpose "update game state".
; we need a DIFFERENT thing for "show game world to player X", which will
; come into play when we're HTTPing.
; right now, the UI **IS** the game state, which is making adding "multiplayer"
; confusing.
= (tick playerId state input)
@ [changed msg] | commandDo playerId input state
| trk [%changed changed]
@ newState | changed
| (print playerId newState msg, tick playerId newState)

; print 2 0 (barUnlines b{welcome. for help, type h<enter>})
= main | tick 1 gis
