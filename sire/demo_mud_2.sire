#### demo_mud_2 <- prelude

; stack run plunder save mud.seed sire/demo_mud_2.sire
; stack run plunder repl mud.seed

:| sire

;102;
;345;
;060;

= grid
, [1 0 2]
  [3 4 5]
  [0 6 0]

;= r [1  0 0 3 0]
;;    id n e s w
= rooms
, [1 0 0 3 0] ;1
  [2 0 0 5 0] ;2
  [3 1 4 0 0] ;3, etc...
  [4 0 5 6 3]
  [5 2 0 0 4]
  [6 4 0 0 0]

= (flatten rows)
@ head (fromSome listHead rows)
@ tail (slice rows 1 (len rows))
| ifNot (len tail)
  head
| weld head (flatten tail)

= (flatGrid)
| flatten grid

; ++ [1 [0 0 3 0]]
; ++ [2 [0 2 4 0]]
; ++ [3 [0 0 5 0]]
; ++ [4 [1 4 0 0]]
; ++ [5 [0 5 6 3]]
; ++ [6 [4 0 0 0]]
= roomPairs | map (x & [(fromSome listHead x) (slice x 1 (len x))]) rooms
= roomT | tabFromPairs roomPairs

= (dirIndex dir)
| if (eql dir b{n}) | 0
| if (eql dir b{e}) | 1
| if (eql dir b{s}) | 2
| if (eql dir b{w}) | 3
0

= (go dir cur)
@ ourRoom (tabGet roomT cur)
| if (eql ourRoom 0)
  | trk [%whereAreYou]
  0
@ nextRoom | get ourRoom | dirIndex dir
# switch nextRoom
* 0
  cur
* _
  nextRoom

; = (me tile currentPosition)
; | if (eql tile currentPosition)
;   b#{@}
; | natBar | showNat tile

= (printARoom current roomId)
; TODO: could use to show directional openings:
; ─ ┌ ┐└ ┘ ├ ┤ ┬ ┴ ┼ │
; TODO: r is a single-entity list (this is dumb. has to do with map below)
@ entrances | tabGet roomT roomId
| if (eql current roomId)
  b#{@}
| if (len entrances)
  b#{.}
b#{#}

; TODO: show current player position
= (print current message)
@ roomz | map (x & tabGet roomT x) flatGrid
@ top | barCat | map (roomId & printARoom current roomId) (slice flatGrid 0 3)
@ mid | barCat | map (roomId & printARoom current roomId) (slice flatGrid 3 6)
@ bot | barCat | map (roomId & printARoom current roomId) (slice flatGrid 6 9)
| barUnlines | intersperse barNewline [top mid bot "" message "" b#{> }]

=?= (dirIndex b{n})
  | 0

=?= (dirIndex b{e})
  | 1

=?= (dirIndex b{s})
  | 2

=?= (dirIndex b{w})
  | 3

=?= (dirIndex b{wut})
  | 0

=?= (go b{s} 4)
  | 6

=?= (go b{e} 4)
  | 5

=?= (go b{w} 4)
  | 3

=?= (go b{n} 1)
  | 1

=?= (go b{x} 4)
  | 4

=?= (go b{n} 9)
  | 0

= (message new old dir)
| if (eql new old)
  b#ouch
| barCat [b#{moved } dir]

= (tick currentPosition input)
@ (dir) | barTakeWhile (neq newlineChar) input
@ newPosition | go dir currentPosition
@ msg | message currentPosition newPosition dir
| (print newPosition msg, tick newPosition)

print 1 (barUnlines b{welcome. move with any of n e s w followed by <enter>})
= main | tick 1

; = (showTodo todo)
; ^ barWeld _ barNewline
; | barIntercalateList barNewline
; : (done,name) < listForEach todo
; ^ barWeld _ name
; | if done
; * b#{[x] }
; * b#{[ ] }
; 
; = (addItem name todo)
; | listNub ((FALSE,name) :: todo)
; 
; = (deleteItem name todo)
; | listFilter (_,n)&(n /= name) todo
; 
; = (doneItem name todo)
; : (done,n) < listForEach todo
; | (done || n==name, n)
; 
; = (step state input)
; @ (cmd, item) | barSplitOne { } | barTakeWhile (neq newlineChar) input
; # switch cmd
; * b#add
;   @ state | addItem item state
;   | (showTodo state, step state)
; * b#del
;   @ state | deleteItem item state
;   | (showTodo state, step state)
; * b#done
;   @ state | doneItem item state
;   | (showTodo state, step state)
; * b#show
;   | (showTodo state, step state)
; * _
;   ^ (_, step state)
;   | barCat [(showTodo state) barNewline b#{Invalid command: } input]
; 
; = main | step ~[]

