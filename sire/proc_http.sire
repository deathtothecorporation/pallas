; Copyright 2024 The OPfN Authors
; Use of this source code is governed by a BSD-style license that can be
; found in the LICENSE file.

#### proc_http <- prelude

; Definite TODOS:
; - Error things:
;   - "If a request contains an entity body and Content-Length is not specified,
;     and the server does not recognize or cannot calculate the length from other
;     fields, then the server should send a 400 (bad request) response."
;
; Things that need to happen:
; - make sure header parsing handles strange things
; - Test passing JSON body in a POST request - probably need to do a bunch after that
; - Properly test the server loop / processMessage flow with multiple
;   connections. re-open / new connections, etc.

:| prelude

# record HTTPRequest
| HTTP_REQ
* method  : Bar             ; HTTP method
* path    : Bar             ; Request URI
* version : Bar             ; HTTP version
* headers : List (Bar, Bar) ; List of key-value pairs
* body    : Bar             ; Request body; may be empty

# record HTTPResponse
| HTTP_RES
* version      : Bar             ; HTTP version
* statusCode   : Nat             ; Numeric status code (for automata)
* reasonPhrase : Bar             ; e.g "OK", "Not Found" (for humans)
* resHeaderL   : List (Bar, Bar) ; List of key-value pairs
* resBody      : Bar             ; Response body

# typedef SenderIP Bar

# typedef ConnectionHandle Bar

; Includes a : between IP and port for legibility
> Bar > Nat > ConnectionHandle
= (bufferKey senderIP senderPort)
| barCat [senderIP b#{:} (natBar | showNat-senderPort)]

# record HTTPBuffer
| HTTP_BUF
* senderIP       : SenderIP
* senderPort     : Nat
* assembledData  : Bar
* headersParsed  : Bit
* headers        : (HMap Bar Bar)
* reqLineParsed  : Bit
* reqLine        : Bar
* contentLength  : Maybe Nat
* chunked        : Bit ; Don't need for 1.0
* receivedLength : Nat
* body           : Bar
* bodyParsed     : Bit

= (emptyBuffer senderIP senderPort)
| HTTP_BUF
* senderIP
* senderPort
* b#{}
* FALSE
* emptyTab
* FALSE
* b#{}
* NONE
* FALSE
* 0
* b#{}

> Bar > Word32
= (ipToWord ipBar)
@ octets (listToRow | barSplit 46 ipBar) ; 46 is ASCII for '.'
| if (neq 4 | len octets)
  | die {Invalid IP address format}
^ foldl _ 0 octets
& (acc octet)
@ value (barLoadDecimal octet)
| if (or (lth value 0) (gth value 255))
  | die {Invalid octet value}
| add (lsh acc 8) value

> Word32 > Bar
= (wordToIp ipWord)
@ octet1 | barShowDecimal (div ipWord 16777216)
@ octet2 | barShowDecimal (mod (div ipWord 65536) 256)
@ octet3 | barShowDecimal (mod (div ipWord 256) 256)
@ octet4 | barShowDecimal (mod ipWord 256)
| barCat [octet1 b#{.} octet2 b#{.} octet3 b#{.} octet4]

= testIp b#{192.168.1.2}
= testWord (ipToWord testIp)
= backToIp (wordToIp testWord)

=?= testIp backToIp

= testIp b#{192.0.0.0}
= testWord (ipToWord testIp)
= backToIp (wordToIp testWord)

=?= testIp backToIp

> Bar > Maybe Nat
= (parseNat bar)
@ wid (barLen bar)
@ hed (barIdx 0 bar)
| maybeGuardNot (isZero wid)
| maybeGuard    (isDigit hed)
@ acc (sub hed {0})
^ (_ acc 1)
? (go acc ix)
| if (gte ix wid) (SOME acc)
@ c (barGet bar ix)
| maybeGuard (isDigit c)
@ !acc (add (mul 10 acc) (sub c {0}))
| go acc inc-ix

> Bar > Bar > List Nat
= (barSubstringSearch needle haystack)
@ needleWidth   (barLen needle)
@ haystackWidth (barLen haystack)
| if (not needleWidth)
    | listTake haystackWidth (listEnumFrom 0)
@ firstByte     (barIdx 0 needle)
^ (_ 0)
? (go off)
@ found (barElemIndexOff firstByte off haystack)
| if (gte found haystackWidth) NIL
@ isMatch (barIsPrefixOf needle haystack found)
@ more    (go | inc found)
| if isMatch (CONS found more)
| else more

; ; TODO: basically unused now that barSubstringLinesList exists.
; > Bar > Maybe Nat
; = (findDoubleCRLF bar)
; @ doubleCRLF x#0d0a
; @ results (barSubstringSearch doubleCRLF bar)
; | listCase results
;     NONE
; & (firstMatch _)
; | SOME firstMatch
;
; ; Using actual x haxes rather than fake b haxes. mostly for \r \n reasons
; ; = testBar | b#{GET /thing HTTP/1.1\nHost: example.com\r\nContent-Type: text/html\r\nContent-Length: 15\r\n\r\nHello, World!}
= testBar | x#474554202F7468696E6720485454502F312E310d0A486F73743A206578616D706C652E636F6D0d0d0A436F6E74656E742D547970653A20746578742F68746D6C0d0A436F6E74656E742D4C656E6774683A2031350d0d0A0d0a48656C6C6F2C20576F726C6421
= testBuffer | HTTP_BUF 9 8888 testBar FALSE emptyTab FALSE b#{} NONE FALSE 0 b#{} FALSE
;
; =?= (SOME 37) | (findDoubleCRLF testBar)

; Like barSubstringLines, but allows splitting on arbitrary characters.
> Bar > Bar > List Bar
= (barSubstringLinesList seek bar)
@ indices (barSubstringSearch seek bar)
@ seekLen (barLen seek)
@ wid (barLen bar)
^ listFilter (compose not barIsEmpty) _
^ _ 0 indices
? (go start idxList)
| listCase idxList
  | CONS (barSlice start (sub wid start) bar) NIL
& (idx rest)
| CONS (barSlice start (sub idx start) bar)
| go (add idx seekLen) rest

(barSubstringLines seek bar)=(listToRow | barSubstringLinesList seek bar)

=?= (listFromRow [x#de x#ad x#20be x#ef])
    | barSubstringLinesList x#0d x#{de0dad0d20be0def0d0d}

=?= [x#de x#ad x#20be x#ef]
    | barSubstringLines x#0d x#{de0dad0d20be0def0d0d}

=?= (listFromRow [x#de x#ad x#20be x#ee x#ef])
    | barSubstringLinesList x#0d x#{de0dad0d20be0dee0def}

=?= (listFromRow [x#de x#ad x#20be x#ef])
    | barSubstringLinesList x#0d x#{0d0dde0dad0d20be0def0d}

=?= (listFromRow [x#de x#ad x#200dbe x#ef])
    | barSubstringLinesList x#0d0a0d x#{de0d0a0dad0d0a0d200dbe0d0a0def0d0a0d}


;; \r\n\r\n ==
; (bytesBar [13 10 13 10])
;;

> Bar > (HMap Bar Bar)
= (extractHeaders headerBar)
@ newline | x#0d0a
@ headerLines | (barSubstringLinesList newline headerBar)
^ listFoldr _ emptyTab headerLines
& (line acc)
@ [key value] | listToRow | barSubstringLinesList b#{: } line
| tabIns key value acc

= testHeaderBar | x#486f73743a206578616d706c652e636f6d0d0a436f6e74656e742d547970653a20746578742f68746d6c0d0a436f6e74656e742d4c656e6774683a2031350d0a
= expectedHeaders | tabFromPairs [[b#Host b#{example.com}] [b#{Content-Type} b#{text/html}] [b#{Content-Length} b#15]]

=?= expectedHeaders | (extractHeaders testHeaderBar)

; Helper for directly below function. Likely retarded.
= (trimBar bar)
^ _ 0 (barLen bar)
? (loop start end)
| if (and (lth start end) (or (eql (barIdx start bar) 32) (eql (barIdx start bar) 9)))
  | loop (inc start) end
| if (and (gth end start) (or (eql (barIdx (dec end) bar) 32) (eql (barIdx (dec end) bar) 9)))
  | loop start (dec end)
| barSlice start (sub end start) bar

> Bar > Bar > Maybe Nat
= (getFirstIdxSubstring sought full)
@ l | barSubstringSearch sought full
| if (eql 0 l)
  NONE
| SOME (listIdx 0 l)

; ; YES, I realize this is an insane function.
; ; don't be insane.
; > Bar > Bar > Maybe Nat
; = (getSecondIdxSubstring sought full)
; @ l | barSubstringSearch sought full
; | if (eql 0 l)
;   NONE
; | SOME (listIdx 1 l)

=?= (0 2) | getFirstIdxSubstring b#x b#aaxaa

=?= (0 2) | getFirstIdxSubstring b#x b#aaxax

=?= (0 0) | getFirstIdxSubstring b#x b#xaaaa

=?= (0 4) | getFirstIdxSubstring b#x b#aaaax

=?= NONE | getFirstIdxSubstring b#x b#aaaaa

=?= (0 2) | getFirstIdxSubstring x#0d x#47470d4747

=?= (0 1) | getFirstIdxSubstring x#0d0a x#470d0a47

; Given an HTTP stream from the beginning, see if its appropriate
; to parse the request line yet, and if so, do it and update the buffer
> Bar > Bar > HTTPBuffer
= (parseAndSetReqline stream buffer)
| if (getReqLineParsed buffer)
  ; already done, nothing to do.
  buffer
; do we have a first 0d0a?
; if not, just return buffer
| maybeCase (getFirstIdxSubstring x#0d0a stream) buffer
; if so, we have a reqline
& idx
; slice from here to the 0d0a
@ rl | barTake idx stream
; put that in reqline
@ buffer | setReqLine rl buffer
; mark it parsed
@ buffer | setReqLineParsed TRUE buffer
buffer

; Given an HTTP stream from the beginning, see if its appropriate
; to parse the headers yet, and if so, do it and update the buffer
> Bar > Bar > HTTPBuffer
= (parseAndSetHeaders stream buffer)
| if | not (getReqLineParsed buffer)
  ; haven't even done request line yet, stop!
  buffer
; now request line is parsed, so we AT LEAST got the first x#0d0a...
; so we should wait until we have _all_ the headers, which is denoted by
; an empty line.
| maybeCase (getFirstIdxSubstring x#0d0a stream) buffer
; if so, we have a reqline
& requestLineIdx
; split at the request line and ignore it
@ [rl remain] | barSplitAt requestLineIdx stream
@ remainTrimmed | barDrop 2 remain
; Again, check to see if we have CRLF yet...
| maybeCase (getFirstIdxSubstring x#0d0a0d0a remainTrimmed) buffer
; if so, we have all the headers
& headersEndIdx
@ h | barTake headersEndIdx remainTrimmed
@ headers | (extractHeaders h)
@ buffer | setHeaders headers buffer
; mark it parsed
@ buffer | setHeadersParsed TRUE buffer
buffer

; Helper for determining if the Request Line looks right
> Bar > Bit
= (validReqLine reqLine)
| if (eql reqLine 0)
  FALSE
@ split | listToRow | barSplit { } reqLine
| if (neq 3 (len split))
  ; we don't have three items
  FALSE
| if (any (x & (or (eql x 0) (eql 0 (barLen x)))) split)
  ; we have three, but some of them are empty?
  | die [split]
  FALSE
TRUE

; Helper for getting the Method
> HTTPBuffer > Maybe Bar
= (mayExplainMethod buffer)
@ reqLine | getReqLine buffer
| if | not (validReqLine reqLine)
  NONE
@ [method uri protocol] | listToRow | barSplit { } reqLine
| SOME method

= testBuffer | HTTP_BUF 9 8888 testBar FALSE emptyTab FALSE b#{GET /foo HTTP/1.1} NONE FALSE 0 b#{} FALSE

=?= (0 b#{GET}) | mayExplainMethod testBuffer

= testBuffer | HTTP_BUF 9 8888 testBar FALSE emptyTab FALSE b#{POST /foo HTTP/1.1} NONE FALSE 0 b#{} FALSE

=?= (0 b#{POST}) | mayExplainMethod testBuffer

= testBuffer | HTTP_BUF 9 8888 testBar FALSE emptyTab FALSE b#{} NONE FALSE 0 b#{} FALSE

=?= NONE | mayExplainMethod testBuffer

; Helper for getting the URI
> HTTPBuffer > Maybe Bar
= (mayExplainUri buffer)
@ reqLine | getReqLine buffer
| if | not (validReqLine reqLine)
  NONE
@ [method uri protocol] | listToRow | barSplit { } reqLine
| SOME uri

= testBuffer | HTTP_BUF 9 8888 testBar FALSE emptyTab FALSE b#{GET /foo HTTP/1.1} NONE FALSE 0 b#{} FALSE

=?= (0 b#{/foo}) | mayExplainUri testBuffer

= testBuffer | HTTP_BUF 9 8888 testBar FALSE emptyTab FALSE b#{asdfsadfsdf} NONE FALSE 0 b#{} FALSE

=?= NONE | mayExplainUri testBuffer

; Helper for getting the HTTP version
> HTTPBuffer > Maybe Bar
= (mayExplainHttpVersion buffer)
@ reqLine | getReqLine buffer
| if | not (validReqLine reqLine)
  NONE
@ [method uri protocol] | listToRow | barSplit { } reqLine
| SOME protocol

= testBuffer | HTTP_BUF 9 8888 testBar FALSE emptyTab FALSE b#{GET /foo HTTP/1.0} NONE FALSE 0 b#{} FALSE

=?= (0 b#{HTTP/1.0}) | mayExplainHttpVersion testBuffer

> (HMap Bar Bar) > Bit
= (haveBodyContent headerMap)
@ haveContentLength | tabGet headerMap b#{Content-Length}
| ifz haveContentLength
  ; No Content-Length header at all
  FALSE
| ifz unpackSome-(parseNat haveContentLength)
  ; Content-Length header, but received a 0 for value
  FALSE
; Non-zero Content-Length header
TRUE

= headersSansContentLength    | tabFromPairs [[b#a b#b] [b#c b#d]]
= headersContentLengthZero    | tabFromPairs [[b#a b#b] [b#{Content-Length} b#0]]
= headersContentLengthNonZero | tabFromPairs [[b#a b#b] [b#{Content-Length} b#15]]

=?= FALSE | (haveBodyContent headersSansContentLength)

=?= FALSE | (haveBodyContent headersContentLengthZero)

=?= TRUE  | (haveBodyContent headersContentLengthNonZero)

; Helper for getting the Content-Length
> HTTPBuffer > Maybe Nat
= (mayExplainContentLength buffer)
| if | not (haveBodyContent (getHeaders buffer))
  NONE
@ cl | tabGet (getHeaders buffer) b#{Content-Length}
parseNat-cl

= headersSansContentLength    | tabFromPairs [[b#a b#b] [b#c b#d]]
= headersContentLengthZero    | tabFromPairs [[b#a b#b] [b#{Content-Length} b#0]]
= headersContentLengthNonZero | tabFromPairs [[b#a b#b] [b#{Content-Length} b#15]]

= clSans | HTTP_BUF 9 8888 testBar FALSE headersSansContentLength FALSE b#{GET /foo HTTP/1.1} NONE FALSE 0 b#{} FALSE
= clZero | HTTP_BUF 9 8888 testBar FALSE headersContentLengthZero FALSE b#{GET /foo HTTP/1.1} NONE FALSE 0 b#{} FALSE
= clSome | HTTP_BUF 9 8888 testBar FALSE headersContentLengthNonZero FALSE b#{GET /foo HTTP/1.1} NONE FALSE 0 b#{} FALSE

=?= NONE    | mayExplainContentLength clSans

=?= NONE    | mayExplainContentLength clZero

=?= SOME-15 | mayExplainContentLength clSome


; TODO: > Bar > Bar > Maybe HTTPBuffer
; Depending on how the stream-parsing goes, if this function sticks around, it
; should be updated to return a Maybe HTTPBuffer - with the NONE case indicating
; some kind of poorly-constructed request error.
> Bar > Bar > HTTPBuffer
= (parseAndSetBody stream buffer)
@ doubleCRLF | x#0d0a0d0a
| if | not (getHeadersParsed buffer)
  ; haven't parsed headers yet, stop!
  buffer
; Do we have a content length? (we should already be guarded against this
; by the fact that this function will not be called in processHttpChunk unless
; there is a content length but its worth being careful)
| maybeCase (mayExplainContentLength buffer) buffer
& contentLength
; Find the first double CRLF - this should be the end of the headers
| maybeCase (getFirstIdxSubstring doubleCRLF stream) buffer
& headersEndIdx
@ body | barDrop (barLen doubleCRLF) | barDrop headersEndIdx stream
@ newReceivedLength | (add (getReceivedLength buffer) | barLen body)
@ buffer | setReceivedLength newReceivedLength buffer
| trk [%thing contentLength]
| trk [%len (barLen body)]
| trk [%lth (lth (barLen body) contentLength)]
| if (gth (barLen body) contentLength)
  ; TODO:
  ; body is longer than headers indicated. bad request!
  NONE
| if (lth (barLen body) contentLength)
  ; we don't have all the content yet. allow the processing to continue
  ; TODO:
  ; | SOME buffer
  buffer
@ buffer | setBody body buffer
@ buffer | setBodyParsed TRUE buffer
; TODO:
; | SOME buffer
buffer

; TODO: write a test that has a request where the body is longer than the content
; length. this should be considered a 400 error

= headersWithContentLength | tabFromPairs [[b#a b#b] [b#{Content-Length} b#1]]
; This assembled data is a full POST request with a body content that is longer than the "Content-Length"
= testAssembledData | x#504F5354202F776861742D69732D6C69666520485454502F312E300d0A486F73743A20676F6F676C652E636F6D0d0A557365722D4167656E743A206375726C2F372E37312E310d0A436F6E74656E742D4C656E6774683A20320d0A0d0A48656C6C6F

= buffer | HTTP_BUF 9999 8888 testAssembledData TRUE headersWithContentLength TRUE b#{POST /what-is-life HTTP/1.0} 1 FALSE (barLen testAssembledData) b#{Hello} TRUE
= badStream | x#48454144202F776861742D69732D6C69666520485454502F312E300d0A486F73743A20676F6F676C652E636F6D0d0A557365722D4167656E743A206375726C2F372E37312E310d0A436F6E74656E742D4C656E6774683A20320d0a0d0a48656C6C6F

; todo try running the other parsers first as a setup

=?= NONE
  | parseAndSetBody badStream buffer

; Take an HTTP chunk of any size and help build a buffer.
; - append into the assembledData
; - if we have the Request Line completed yet, set it in the buffer
; - if we have all the headers completed yet, set them in the buffer
; - if we have a body, set it in the buffer
;
; TODO: this is a sort of crummy pattern. Each of the parseAndSet* things below
; runs every time, and each of those (see their bodies) have some repeated
; logic for dealing with the _entire_ assembledData bar.
; We should  do this more efficiently and in such a way that:
; - this can return a Maybe (so that a consumer knows that NONE == malformed)
; - the individual parsers aren't running unnecessarily
; - the individual parsers don't have logic from othe responsibilities mixed in
= (processHttpChunk buffer chunk)
@ newAssembledData  | (barWeld (getAssembledData buffer) chunk)
@ buffer | setAssembledData newAssembledData buffer
@ buffer | parseAndSetReqline newAssembledData buffer
@ buffer | parseAndSetHeaders newAssembledData buffer
| if (haveBodyContent (getHeaders buffer))
  @ buffer | parseAndSetBody newAssembledData buffer
  buffer
buffer

> HTTPBuffer > Bit
= (isMessageComplete buffer)
; headers are parsed and we don't have a body.
| if (and isNone-(mayExplainContentLength buffer) (getHeadersParsed buffer))
  TRUE
; have a body and we've parsed in the full length of it
| if (and isSome-(mayExplainContentLength buffer) (eql unpackSome-mayExplainContentLength (getReceivedLength buffer)))
  TRUE
FALSE

; For testing.
> Row Bar > HTTPBuffer
= (fakeProcessConnection fakeIn buffer)
| if (eql 0 (len fakeIn))
  | trk [%ranOuttaIns]
  ; | todo "what does this case actually mean?"
  buffer
@ [data remainder] | splitAt 1 fakeIn ; consider first item
@ updatedBuffer | processHttpChunk buffer (idx 0 data)
| if (isMessageComplete updatedBuffer)
  updatedBuffer
| fakeProcessConnection remainder updatedBuffer

; TODO:
= (makeMessage buffer)
b#{thing}

> (HMap Bar Bar) > Nat > Bar > > Bar > HTTPResponse
= (appResponseToHTTP headers body code reason)
; TODO: check validity of headers/body/code we got from app here
; Formulate an HTTPResponse anyway (probably a 500 or whatever)
;
; We're returning a Maybe here in case this function should be the one
; that catches invalid inputs and tells its consumer to return an error
; - check format/validity, re: error codes
;   - server do whatver else it needs
; TODO:
; - reason phrase should come from app but be overridable by server in case error
@ version      | b#{HTTP/1.0}
@ statusCode   | code
@ reasonPhrase | reason
@ body         | body
@ contentLength | natBar | showNat | barLen body ; should be zero if not present
@ headers | tabIns b#{Content-Length} contentLength headers
@ headers | tabIns b#{Server} b#{Pallas/0.1} headers
; TODO: need
; @ headers | tabIns b#{Date}
; TODO: others, maybe:
; @ headers | tabIns b#{Content-Encoding}
; @ headers | tabIns b#{Content-Type}
; This concatenation with colons _could_ be done in a subsequent function that
; is responsible for HTTP_RES -> Hex Bar
@ headersList
  | tabValsList
  | tabMapWithKey
  (k v & (barCat [k b#{: } v]))
  headers
| HTTP_RES
* version
* statusCode
* reasonPhrase
* headersList
* body

= appHeaders | tabFromPairs [[b#hello b#world] [b#cookie b#thing]]
= expectedHeaderList | listFromRow [b#{hello: world} b#{cookie: thing} b#{Server: Pallas/0.1} b#{Content-Length: 3}]

= expectedRes
| HTTP_RES
* b#{HTTP/1.0}
* 200
* b#aight
* expectedHeaderList
* b#{wut}

=?= expectedRes
  | appResponseToHTTP appHeaders b#{wut} 200 b#{aight}

; TODO:
; take a valid HTTP Response and create an HTTP-1.0-compliant hex array
> HTTPResponse > Bar
= (httpResToBar httpRes)
@ crlf  | x#0d0a
@ v     | (getVersion      httpRes)
@ c     | (getStatusCode   httpRes)
@ s     | (getReasonPhrase httpRes)
@ h     | (getResHeaderL   httpRes)
@ b     | (getResBody      httpRes)
@ noBod | (or (barIsEmpty b) (eql 0 b))
@ mBody | if noBod NONE | else SOME b
@ mBSep | if noBod NONE | else SOME (barCat [crlf crlf])
@ statusLine         | barCat [v x#20 (natBar | showNat c) x#20 s]
@ headersSeparated   | barIntercalateList crlf h
@ printBodySeparator | fromSome NIL mBSep
@ printBody          | fromSome NIL mBody
| barCat
  , statusLine
    crlf
    headersSeparated
    printBodySeparator
    printBody

= appHeaders | tabFromPairs [[b#Server b#{Pallas/0.1}] [b#Date b#{Tue, 24 Sep 2024 12:00:00 GMT}] [b#{Content-Type} b#{text/plain; charset=UTF-8}] [b#{Content-Length} b#{9}]]
= preparedResponse | appResponseToHTTP appHeaders b#{Nice body} 200 b#{OK}

= hexResponse
  | barCat
  , b#{HTTP/1.0 200 OK}
    x#0d0a
    b#{Date: Tue, 24 Sep 2024 12:00:00 GMT}
    x#0d0a
    b#{Server: Pallas/0.1}
    x#0d0a
    b#{Content-Type: text/plain; charset=UTF-8}
    x#0d0a
    b#{Content-Length: 9}
    x#0d0a0d0a
    b#{Nice body}

= inHex
  | x#485454502F312E3020323030204F4B0d0A446174653A205475652C2032342053657020323032342031323A30303A303020474D540d0A5365727665723A2050616C6C61732F302E310d0A436F6E74656E742D547970653A20746578742F706C61696E3B20636861727365743D5554462D380d0A436F6E74656E742D4C656E6774683A20390d0A0d0a4E69636520626F6479

; Sanity check that our barCat-constructed, human-readable response is equivalent
; to its proper hex representation:
=?= inHex | hexResponse

=?= inHex
   | (httpResToBar preparedResponse)

= hex2
  | barCat
  , b#{HTTP/1.0 204 OK}
    x#0d0a
    b#{Date: Tue, 24 Sep 2024 12:00:00 GMT}
    x#0d0a
    b#{Server: Pallas/0.1}
    x#0d0a
    b#{Content-Length: 0}

= appHeaders | tabFromPairs [[b#Server b#{Pallas/0.1}] [b#Date b#{Tue, 24 Sep 2024 12:00:00 GMT}]]
= prep2 | appResponseToHTTP appHeaders b#{} 204 b#{OK}

=?= hex2
   | (httpResToBar prep2)

= hexNoBod
  | barCat
  , b#{HTTP/1.0 204 GotHead}
    x#0d0a
    b#{Date: Tue, 24 Sep 2024 12:00:00 GMT}
    x#0d0a
    b#{Server: Pallas/0.1}
    x#0d0a
    b#{Content-Length: 0}

= appHeaders | tabFromPairs [[b#Server b#{Pallas/0.1}] [b#Date b#{Tue, 24 Sep 2024 12:00:00 GMT}]]
= prepBodless | appResponseToHTTP appHeaders NIL 204 b#{GotHead}

=?= hexNoBod
  | (httpResToBar prepBodless)

; TODO:
> HTTPBuffer > Bit
= (validRequest request)
; early response for malformed requests - potentially depends on better strategy
; for _short-circuiting_ message chunk ingesting. See processHTTPChunk.
TRUE

; TODO:
> HTTPResponse > Bit
= (validResponse response)
; did we get a garbage response from the app?
; if so, we shouldn't send it out.
; return either a bar to be sent out, or nothing (maybe)
;
; Do the validation work here. call this in appResponseToHTTP
TRUE

= (processConnection io getResponse buffer return)
: data < syscall | TCP_TAKE io
| if (barIsEmpty data)
  | trk [%connectionClosed %dataBarEmpty]
  ; | todo [%gotEmptyData buffer]
  | return ()
@ updatedBuffer | processHttpChunk buffer data
; maybe switch to maybeCase on the result above:
| trk [%updatedBuffer updatedBuffer]
; TODO: processHttpChunk will change to a Maybe
; The updatedBuffer will either be empty (not done yet)
; or an HTTPBuffer.
; So we're not going to need isMessageComplete after that.
| ifNot (isMessageComplete updatedBuffer)
  | trk [%processConnectionRecurring]
  | processConnection io updatedBuffer return
| trk [%processConnectionDone]
; after above parsing changes, won't need makeMessage. just give buffer directly
: response < getResponse | makeMessage updatedBuffer
;            (hed bar code)
@ response ; TODO use appResponseToHTTP
  | if (validResponse response) response ; change to maybe stuff.
  | b#{internal server error} ; TODO correct format
^ _ response
; TODO: apply httpResToBar to response before sending to TCP
? (sendAndClose response)
: mBytes < syscall | TCP_GIVE io response
| trk [%sent mBytes]
: bytes  < maybeCase mBytes  | syscall (TCP_SHUT io) return
| if (barLen response == bytes) | syscall (TCP_SHUT io) return
| sendAndClose | barDrop bytes response

= testIP | b#{192.168.10.10}
= testIpWord | ipToWord testIP

; Entire TCP packet from WireShark:
; = testPacket | x#0000000000000000000000000800450002886f6440004006bb097f0000017f000001800ace6f124ebb61a8099d2780180200007d00000101080a75b32e7e75b32db1474554202f6e6f746520485454502f312e310d0a486f73743a206c6f63616c686f73743a35323834370d0a557365722d4167656e743a204d6f7a696c6c612f352e3020285831313b205562756e74753b204c696e7578207838365f36343b2072763a3132392e3029204765636b6f2f32303130303130312046697265666f782f3132392e300d0a4163636570743a202a2f2a0d0a4163636570742d4c616e67756167653a20656e2d55532c656e3b713d302e350d0a4163636570742d456e636f64696e673a20677a69702c206465666c6174652c2062722c207a7374640d0a526566657265723a20687474703a2f2f6c6f63616c686f73743a35323834372f0d0a436f6e6e656374696f6e3a206b6565702d616c6976650d0a436f6f6b69653a205f706b5f69642e322e316666663d353966343331626532303136396566332e313731373630313536392e3b205f706b5f69642e312e316666663d306261313033373862393362356238332e313731373631323234312e3b20706c756e64617574682d3d353439356562653035616264613961636633366130363733323138383866383133613366353366396461643739623330303032626435623764393036653533623b20435352462d546f6b656e2d35325241353d36507172555464506a5171416854515268725167434b754b6b35794172626b550d0a5365632d46657463682d446573743a20656d7074790d0a5365632d46657463682d4d6f64653a20636f72730d0a5365632d46657463682d536974653a2073616d652d6f726967696e0d0a5072696f726974793a20753d340d0a0d0a

; Same as above, but includes "hello world" body I shoved in.
; = testPacket | x#0000000000000000000000000800450002886f6440004006bb097f0000017f000001800ace6f124ebb61a8099d2780180200007d00000101080a75b32e7e75b32db1474554202f6e6f746520485454502f312e310d0a486f73743a206c6f63616c686f73743a35323834370d0a557365722d4167656e743a204d6f7a696c6c612f352e3020285831313b205562756e74753b204c696e7578207838365f36343b2072763a3132392e3029204765636b6f2f32303130303130312046697265666f782f3132392e300d0a4163636570743a202a2f2a0d0a4163636570742d4c616e67756167653a20656e2d55532c656e3b713d302e350d0a4163636570742d456e636f64696e673a20677a69702c206465666c6174652c2062722c207a7374640d0a526566657265723a20687474703a2f2f6c6f63616c686f73743a35323834372f0d0a436f6e6e656374696f6e3a206b6565702d616c6976650d0a436f6f6b69653a205f706b5f69642e322e316666663d353966343331626532303136396566332e313731373630313536392e3b205f706b5f69642e312e316666663d306261313033373862393362356238332e313731373631323234312e3b20706c756e64617574682d3d353439356562653035616264613961636633366130363733323138383866383133613366353366396461643739623330303032626435623764393036653533623b20435352462d546f6b656e2d35325241353d36507172555464506a5171416854515268725167434b754b6b35794172626b550d0a5365632d46657463682d446573743a20656d7074790d0a5365632d46657463682d4d6f64653a20636f72730d0a5365632d46657463682d536974653a2073616d652d6f726967696e0d0a5072696f726974793a20753d340d0a0d0a68656c6c6f20776f726c64

; An HTTP-only packet (no TCP stuff!), taken from the above wireshark packet.
; This is more appropriate for testing this cog
= testPacketHTTPOnly | x#474554202f6e6f746520485454502f312e310d0a486f73743a206c6f63616c686f73743a35323834370d0a557365722d4167656e743a204d6f7a696c6c612f352e3020285831313b205562756e74753b204c696e7578207838365f36343b2072763a3132392e3029204765636b6f2f32303130303130312046697265666f782f3132392e300d0a4163636570743a202a2f2a0d0a4163636570742d4c616e67756167653a20656e2d55532c656e3b713d302e350d0a4163636570742d456e636f64696e673a20677a69702c206465666c6174652c2062722c207a7374640d0a526566657265723a20687474703a2f2f6c6f63616c686f73743a35323834372f0d0a436f6e6e656374696f6e3a206b6565702d616c6976650d0a436f6f6b69653a205f706b5f69642e322e316666663d353966343331626532303136396566332e313731373630313536392e3b205f706b5f69642e312e316666663d306261313033373862393362356238332e313731373631323234312e3b20706c756e64617574682d3d353439356562653035616264613961636633366130363733323138383866383133613366353366396461643739623330303032626435623764393036653533623b20435352462d546f6b656e2d35325241353d36507172555464506a5171416854515268725167434b754b6b35794172626b550d0a5365632d46657463682d446573743a20656d7074790d0a5365632d46657463682d4d6f64653a20636f72730d0a5365632d46657463682d536974653a2073616d652d6f726967696e0d0a5072696f726974793a20753d340d0a0d0a68656c6c6f20776f726c64

= (splitBarIntoSegmentsList segSize bar)
@ wid (barLen bar)
^ (_ 0)
? (go off)
| if (gte off wid) NIL
@ end (add off segSize)
| CONS (barSlice off (sub end off) bar)
| go end

(splitBarIntoSegments segSize bar)=(listToRow | splitBarIntoSegmentsList segSize bar)

=?= [b#hel b#{lo } b#wor b#{ld.}]
  | splitBarIntoSegments 3 b#{hello world.}

=?= [b#he b#{ll} b#{o } b#{wo} b#{rl} b#{d!} b#{!}]
  | splitBarIntoSegments 2 b#{hello world!!}

=?= [b#{hello world.}]
  | splitBarIntoSegments 1000 b#{hello world.}

7777
7777
7777
7777
7777
7777

= emptyBuffer | HTTP_BUF 9999 8888 b#{} FALSE emptyTab FALSE b#{} NONE FALSE 0 b#{} FALSE
= headersTab
| tabFromPairs
, [b#{Host} b#{google.com}]
  [b#{Accept} b#{*/*}]
  [b#{User-Agent} b#{curl/7.71.1}]
  [b#{Content-Type} b#{text/plain}]
  [b#{Content-Length} b#{11}]

= httpPostWithBody | x#504f5354202f776861742d69732d6c69666520485454502f312e300d0a486f73743a20676f6f676c652e636f6d0d0a557365722d4167656e743a206375726c2f372e37312e310d0a4163636570743a202a2f2a0d0a436f6e74656e742d547970653a20746578742f706c61696e0d0a436f6e74656e742d4c656e6774683a2031310d0a0d0a68656c6c6f20776f726c64

= splitHTTPRow | splitBarIntoSegments 5 httpPostWithBody

= expectedBuffer | HTTP_BUF 9999 8888 httpPostWithBody TRUE headersTab TRUE b#{POST /what-is-life HTTP/1.0} NONE FALSE 600 b#{hello world} FALSE

= assembledBuffer | fakeProcessConnection splitHTTPRow emptyBuffer

;;; Integration tests for entire process connection -> set record fields flow
;;; on simulated re-assembled HTTP message from chunks

=?= (getReqLine expectedBuffer)
  | getReqLine assembledBuffer

=?= (getReqLineParsed expectedBuffer)
  | getReqLineParsed assembledBuffer

=?= (getHeaders expectedBuffer)
  | getHeaders assembledBuffer

=?= (getHeadersParsed expectedBuffer)
  | getHeadersParsed assembledBuffer

=?= (getBody expectedBuffer)
   | getBody assembledBuffer

= httpGetNoBody | x#474554202f776861742d69732d6c69666520485454502f312e300d0a486f73743a20676f6f676c652e636f6d0d0a557365722d4167656e743a206375726c2f372e37312e310d0a4163636570743a202a2f2a0d0a0d0a

= splitHTTPRow | splitBarIntoSegments 5 httpGetNoBody

= headersTab
| tabFromPairs
, [b#{Host} b#{google.com}]
  [b#{Accept} b#{*/*}]
  [b#{User-Agent} b#{curl/7.71.1}]

= expectedBuffer | HTTP_BUF 9999 8888 httpGetNoBody TRUE headersTab TRUE b#{GET /what-is-life HTTP/1.0} NONE FALSE 600 b#{} FALSE

= assembledBuffer | fakeProcessConnection splitHTTPRow emptyBuffer

=?= (getReqLine expectedBuffer)
  | getReqLine assembledBuffer

=?= (getBody expectedBuffer)
   | getBody assembledBuffer

= httpHead | x#48454144202f776861742d69732d6c69666520485454502f312e300d0a486f73743a20676f6f676c652e636f6d0d0a557365722d4167656e743a206375726c2f372e37312e310d0a4163636570743a202a2f2a0d0a0d0a

= splitHTTPRow | splitBarIntoSegments 5 httpHead

= headersTab
| tabFromPairs
, [b#{Host} b#{google.com}]
  [b#{Accept} b#{*/*}]
  [b#{User-Agent} b#{curl/7.71.1}]

= expectedBuffer | HTTP_BUF 9999 8888 httpHead TRUE headersTab TRUE b#{HEAD /what-is-life HTTP/1.0} NONE FALSE 600 b#{} FALSE

= assembledBuffer | fakeProcessConnection splitHTTPRow emptyBuffer

=?= (getReqLine expectedBuffer)
  | getReqLine assembledBuffer

=?= (getBody expectedBuffer)
   | getBody assembledBuffer

= (httpServer responseHandler return)
: port < syscall | TCP_MINE
| trk [%our [=port]]
: [io ip port] < syscall | TCP_HEAR
; TODO: use ipToWord
; ip and port from who connected to us.
| trk [%their [=io =ip =port]]
: tid < pumpFork (httpServer responseHandler)
| processConnection io responseHandler (emptyBuffer ip port) return


; TODO: use ipToWord?
= (hydrate return)
: port < syscall | TCP_MINE
: mout < syscall | TCP_OPEN 16777343 port ; 16777343 == 127.0.0.1
| trk [=mout]
: io  < maybeCase mout | return ()
| trk [=io]
: gave < syscall | TCP_GIVE io testPacketHTTPOnly
| trk [=gave]
; now we're done setting up the test data
;
| return ()

; TODO: should be Proc HTTPResponse
> HTTPRequest > HTTPResponse
; This is here for testing purposes.
; In the real world, this will be defined in the cog that uses this proc.
= (responseHandler msg) | syscall | DB_READ msg

= main
: exit < runCog 0 (_ _ _ & b#success)
; first zero above: starting (public) state.
; for the lambda's three arguments being ignored:
; - the cog's public state (not its private closure)
; - procID
; - the actual message (that we are passing in)
| trk %started_http
: _ < work EXEC-hydrate id
| trk %started_hydrate
: _ < work EXEC-(httpServer responseHandler) id
| trk %started_server
| exit ()
