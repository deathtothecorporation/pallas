#### cog_http <- prelude

;; TODO:
;; - HTTP messages that span multiple TCP packets

:| prelude

;;;; some byte styff

; little endian! 800a hex == 32778, but barNat only registers this as little endian: 0a80
= (u32FromBytesLSB a b c d)
| add32 a
| add32 (lsh32 b 8)
| add32 (lsh32 c 16)
        (lsh32 d 24)

; breaks a nat that represents a word into
; its little-endian component bytes
(wordToBytes a)=(gen 4 i&(con 0xff (rsh a (mul 8 i))))

; Little Endian Byte order
> Row Word32 > Row Word8
(wordsToBytes wv)=(catMap wordToBytes wv)

; Take a big-endian hex bar and conver it to the correct Nat
> Bar > Nat
= (barToNatBE bar)
@ bytes | (barBytes bar)
@ reversedBytes | (rev bytes)
| if (eql 2 | len bytes)
    | u32FromBytesLSB
        (get reversedBytes 0)
        (get reversedBytes 1)
        0
        0
| if (eql 4 | len bytes)
    | u32FromBytesLSB
        (get reversedBytes 0)
        (get reversedBytes 1)
        (get reversedBytes 2)
        (get reversedBytes 3)
| die {barToNatBE only supports 2 or 4 byte bars}

=?= 32778 (barToNatBE x#800a)
=?= 52847 (barToNatBE x#ce6f)

;;;; header parsing helpers

= (barSplitCRLF bar)
| trk %barSplitCRLF
| trk [%bar bar]
| barSplitOne 10 bar

= (barSplitColon bar)
| trk %barSplitColon
| trk [%bar bar]
| barSplitOne 58 bar

= (trimSpace bar)
| trk %trimSpace
| trk [%bar bar]
| barDropWhile (eql 32) bar

= (parseHeader headerBar)
| trk %parseHeader
| trk [%headerBar headerBar]
@ [key value] | barSplitColon headerBar
| trk [%key key]
| trk [%val value]
@ trimmedValue | trimSpace value
[key trimmedValue]

= (parseHeaders headersBar)
| trk %parseHeaders
| trk [%headersBar headersBar]
@ headersList | barSplitCRLF headersBar
| trk [%xxxxxheadersList headersList]
| map parseHeader headersList

;;;;


# record HTTPRequest
| HTTP_REQ
* method  : Bar             ; HTTP method
* path    : Bar             ; Request URI
* version : Bar             ; HTTP version
* headers : List (Bar, Bar) ; List of key-value pairs
* body    : Bar             ; Request body; may be empty

# record HTTPResponse
| HTTP_RES
* version    : Bar             ; HTTP version
* statusCode : Nat             ; Numeric status code
* statusText : Bar             ; Status text (e.g "OK", "Not Found")
* headers    : List (Bar, Bar) ; List of key-value pairs
* body       : Bar             ; Response body

; from WireShark:
; = testPacket | x#0000000000000000000000000800450002886f6440004006bb097f0000017f000001800ace6f124ebb61a8099d2780180200007d00000101080a75b32e7e75b32db1474554202f6e6f746520485454502f312e310d0a486f73743a206c6f63616c686f73743a35323834370d0a557365722d4167656e743a204d6f7a696c6c612f352e3020285831313b205562756e74753b204c696e7578207838365f36343b2072763a3132392e3029204765636b6f2f32303130303130312046697265666f782f3132392e300d0a4163636570743a202a2f2a0d0a4163636570742d4c616e67756167653a20656e2d55532c656e3b713d302e350d0a4163636570742d456e636f64696e673a20677a69702c206465666c6174652c2062722c207a7374640d0a526566657265723a20687474703a2f2f6c6f63616c686f73743a35323834372f0d0a436f6e6e656374696f6e3a206b6565702d616c6976650d0a436f6f6b69653a205f706b5f69642e322e316666663d353966343331626532303136396566332e313731373630313536392e3b205f706b5f69642e312e316666663d306261313033373862393362356238332e313731373631323234312e3b20706c756e64617574682d3d353439356562653035616264613961636633366130363733323138383866383133613366353366396461643739623330303032626435623764393036653533623b20435352462d546f6b656e2d35325241353d36507172555464506a5171416854515268725167434b754b6b35794172626b550d0a5365632d46657463682d446573743a20656d7074790d0a5365632d46657463682d4d6f64653a20636f72730d0a5365632d46657463682d536974653a2073616d652d6f726967696e0d0a5072696f726974793a20753d340d0a0d0a

; includes "hello world" body I shoved in.
= testPacket | x#0000000000000000000000000800450002886f6440004006bb097f0000017f000001800ace6f124ebb61a8099d2780180200007d00000101080a75b32e7e75b32db1474554202f6e6f746520485454502f312e310d0a486f73743a206c6f63616c686f73743a35323834370d0a557365722d4167656e743a204d6f7a696c6c612f352e3020285831313b205562756e74753b204c696e7578207838365f36343b2072763a3132392e3029204765636b6f2f32303130303130312046697265666f782f3132392e300d0a4163636570743a202a2f2a0d0a4163636570742d4c616e67756167653a20656e2d55532c656e3b713d302e350d0a4163636570742d456e636f64696e673a20677a69702c206465666c6174652c2062722c207a7374640d0a526566657265723a20687474703a2f2f6c6f63616c686f73743a35323834372f0d0a436f6e6e656374696f6e3a206b6565702d616c6976650d0a436f6f6b69653a205f706b5f69642e322e316666663d353966343331626532303136396566332e313731373630313536392e3b205f706b5f69642e312e316666663d306261313033373862393362356238332e313731373631323234312e3b20706c756e64617574682d3d353439356562653035616264613961636633366130363733323138383866383133613366353366396461643739623330303032626435623764393036653533623b20435352462d546f6b656e2d35325241353d36507172555464506a5171416854515268725167434b754b6b35794172626b550d0a5365632d46657463682d446573743a20656d7074790d0a5365632d46657463682d4d6f64653a20636f72730d0a5365632d46657463682d536974653a2073616d652d6f726967696e0d0a5072696f726974793a20753d340d0a0d0a68656c6c6f20776f726c64

= testPacketHTTPOnly | x#474554202f6e6f746520485454502f312e310d0a486f73743a206c6f63616c686f73743a35323834370d0a557365722d4167656e743a204d6f7a696c6c612f352e3020285831313b205562756e74753b204c696e7578207838365f36343b2072763a3132392e3029204765636b6f2f32303130303130312046697265666f782f3132392e300d0a4163636570743a202a2f2a0d0a4163636570742d4c616e67756167653a20656e2d55532c656e3b713d302e350d0a4163636570742d456e636f64696e673a20677a69702c206465666c6174652c2062722c207a7374640d0a526566657265723a20687474703a2f2f6c6f63616c686f73743a35323834372f0d0a436f6e6e656374696f6e3a206b6565702d616c6976650d0a436f6f6b69653a205f706b5f69642e322e316666663d353966343331626532303136396566332e313731373630313536392e3b205f706b5f69642e312e316666663d306261313033373862393362356238332e313731373631323234312e3b20706c756e64617574682d3d353439356562653035616264613961636633366130363733323138383866383133613366353366396461643739623330303032626435623764393036653533623b20435352462d546f6b656e2d35325241353d36507172555464506a5171416854515268725167434b754b6b35794172626b550d0a5365632d46657463682d446573743a20656d7074790d0a5365632d46657463682d4d6f64653a20636f72730d0a5365632d46657463682d536974653a2073616d652d6f726967696e0d0a5072696f726974793a20753d340d0a0d0a68656c6c6f20776f726c64

# typedef SenderIP Bar

# typedef ConnectionHandle Bar

; Includes a : between IP and port for legibility
> Bar > Nat > ConnectionHandle
= (bufferKey senderIP senderPort)
| barCat [senderIP b#{:} (natBar | showNat-senderPort)]

# record HTTPBuffer
| HTTP_BUF
* senderIP       : SenderIP
* senderPort     : Nat
* assembledData  : Bar
* headersParsed  : Bit
* contentLength  : Maybe Nat
* chunked        : Bit
* receivedLength : Nat

= (emptyBuffer senderIP senderPort)
| HTTP_BUF
* senderIP
* senderPort
* b#{}
* FALSE
* NONE
* FALSE
* 0

# record CogState
| COG_STATE
* buffers    : (HMap ConnectionHandle HTTPBuffer)
* servThread : ThreadId

> ThreadId > CogState
= (newCogState servThread)
| COG_STATE
* emptyTab
* 0

= (modifyState vSt fun return)
: (PIN old) < readRef vSt
@ srv       | getServThread old
@ pNew      | PIN (fun old)
: _         < writeRef vSt pNew
; : _         < cancelFork srv (syscall (HTTP_SERV | fileServer pNew))
| return ()

= (corsHeaders)
[]

= testIP | b#{192.168.10.10}
= ipWord | ipToWord testIP

; TODO: quite sure this doesn't work but haven't tested it yet
= (findDoubleCRLF bar)
@ crlfBar | b#{\r\n\r\n}
^ _ 0
? (loop i)
| if (gte (add i 4) | barLen bar) NONE
| if (eql crlfBar | barSlice i 4 bar)
  | SOME i
| loop (inc i)

= (findContentLength headers)
^ foldr _ NONE headers
& (header result)
@ [name value] | header
| if (eql name b#{Content-Length})
  | SOME (barLoadDecimal value)
result

= (trimBar bar)
^ _ 0 (barLen bar)
? (loop start end)
| if (and (lth start end) (or (eql (barIdx start bar) 32) (eql (barIdx start bar) 9)))
  | loop (inc start) end
| if (and (gth end start) (or (eql (barIdx (dec end) bar) 32) (eql (barIdx (dec end) bar) 9)))
  | loop start (dec end)
| barSlice start (sub end start) bar

= (isChunked headers)
^ foldr _ FALSE headers
& (header result)
@ [name value] | header
| if (and (eql name b#{Transfer-Encoding}) (eql (trimBar value) b#{chunked}))
  TRUE
result

; TODO: fucking up the buffer tab
= (processHttpChunk buffer chunk)
| trk [%processHttpChunk [buffer chunk]]
| trk [%xxxx buffer]
@ newAssembledData  | (barWeld (getAssembledData buffer) chunk)
@ newReceivedLength | (add (getReceivedLength buffer) | barLen chunk)
| trk [%newAssembled newAssembledData]
| trk [%newRecLen newReceivedLength]
| trk [%buffer buffer]
@ buffer | setAssembledData newAssembledData buffer
@ buffer | setReceivedLength newReceivedLength buffer
| if (not | (getHeadersParsed buffer))
  | trk [%headersNotParsed]
  @ headerEnd | (findDoubleCRLF newAssembledData)
  | trk [%headerEnd headerEnd]
  | maybeCase headerEnd
      buffer
  & i
  @ headers | (parseHeaders | barSlice 0 i newAssembledData)
  @ contentLength | (findContentLength headers)
  @ chunked | (isChunked headers)
  @ buffer | setHeadersParsed TRUE buffer
  @ buffer | setContentLength contentLength buffer
  @ buffer | setChunked chunked buffer
  buffer
| trk [%headersParsed]
buffer

= (handleCompletedMessage buffer)
| trk [%completedMessage buffer]
| emptyBuffer 555 333

= (isMessageComplete buffer)
| trk [%checkIsComplete buffer]
| if (getChunked buffer)
  | trk [%TODOsuffixThings]
  TRUE ; TODO:
  ; | barIsSuffixOf x#0d0a30d0a0d0a (tabGet buffer b#assembledData)
| trk [%notSuffix]
| maybeCase (getContentLength buffer) | FALSE
& expectedLength
| trk [%gteThings]
| trk [%expectedLength expectedLength]
| gte (getReceivedLength buffer) expectedLength

= (processConnection in buffer return)
| trk [%processConnection in buffer]
: data < syscall | TCP_TAKE in
| trk [%data data]
| if (barIsEmpty data) ; check to see if we're done with HTTP message
  | trk [%connectionClosed]
  ;| emptyBuffer
  | return ()
@ updatedBuffer | processHttpChunk buffer data
| trk [%updatedBuffer updatedBuffer]
| if (isMessageComplete updatedBuffer)
  | trk [%processConnectionDone]
  @ newBuffer | handleCompletedMessage updatedBuffer
  | processConnection in newBuffer
| trk [%processConnectionRecurring]
| processConnection in updatedBuffer

= (serverLoop in return)
| processConnection in (emptyBuffer ipWord 8888) return
; | serverLoop in return

= main
: exit < runCog
; open a connection for the sake of hydrating with some test packet data
: mout < syscall | TCP_OPEN ipWord 9999
| trk [=mout]
: out  < maybeCase mout | exit ()
| trk [=out]
: gave < syscall | TCP_GIVE out testPacketHTTPOnly
| trk [=gave]
; now we're done setting up the test data
;
; create a connection handle:
: in   < syscall | TCP_HEAR ; todo: we'll need "infinite of these" / re-create when done.
| trk [=in]
; give that connection handle to the main loop:
| serverLoop in exit
