#### cog_http <- prelude

;; TODO:
;; - HTTP messages that span multiple TCP packets

:| prelude

;;;; some byte styff

; little endian! 800a hex == 32778, but barNat only registers this as little endian: 0a80
= (u32FromBytesLSB a b c d)
| add32 a
| add32 (lsh32 b 8)
| add32 (lsh32 c 16)
        (lsh32 d 24)

; breaks a nat that represents a word into
; its little-endian component bytes
(wordToBytes a)=(gen 4 i&(con 0xff (rsh a (mul 8 i))))

; Little Endian Byte order
> Row Word32 > Row Word8
(wordsToBytes wv)=(catMap wordToBytes wv)

; Take a big-endian hex bar and conver it to the correct Nat
> Bar > Nat
= (barToNatBE bar)
@ bytes | (barBytes bar)
@ reversedBytes | (rev bytes)
| if (eql 2 | len bytes)
    | u32FromBytesLSB
        (get reversedBytes 0)
        (get reversedBytes 1)
        0
        0
| if (eql 4 | len bytes)
    | u32FromBytesLSB
        (get reversedBytes 0)
        (get reversedBytes 1)
        (get reversedBytes 2)
        (get reversedBytes 3)
| die {barToNatBE only supports 2 or 4 byte bars}

=?= 32778 (barToNatBE x#800a)
=?= 52847 (barToNatBE x#ce6f)

;;;; header parsing helpers

= (barSplitCRLF bar)
| trk %barSplitCRLF
| trk [%bar bar]
| barSplitOne 10 bar

= (barSplitColon bar)
| trk %barSplitColon
| trk [%bar bar]
| barSplitOne 58 bar

= (trimSpace bar)
| trk %trimSpace
| trk [%bar bar]
| barDropWhile (eql 32) bar

; = (parseHeader headerBar)
; | trk %parseHeader
; | trk [%headerBar headerBar]
; @ [key value] | barSplitColon headerBar
; | trk [%key key]
; | trk [%val value]
; @ trimmedValue | trimSpace value
; [key trimmedValue]

; = (parseHeaders headersBar)
; | trk %parseHeaders
; | trk [%headersBar headersBar]
; @ headersList | barSplitCRLF headersBar
; | trk [%xxxxxheadersList headersList]
; | map parseHeader headersList

;;;;


# record HTTPRequest
| HTTP_REQ
* method  : Bar             ; HTTP method
* path    : Bar             ; Request URI
* version : Bar             ; HTTP version
* headers : List (Bar, Bar) ; List of key-value pairs
* body    : Bar             ; Request body; may be empty

# record HTTPResponse
| HTTP_RES
* version    : Bar             ; HTTP version
* statusCode : Nat             ; Numeric status code
* statusText : Bar             ; Status text (e.g "OK", "Not Found")
* headers    : List (Bar, Bar) ; List of key-value pairs
* body       : Bar             ; Response body

; from WireShark:
; = testPacket | x#0000000000000000000000000800450002886f6440004006bb097f0000017f000001800ace6f124ebb61a8099d2780180200007d00000101080a75b32e7e75b32db1474554202f6e6f746520485454502f312e310d0a486f73743a206c6f63616c686f73743a35323834370d0a557365722d4167656e743a204d6f7a696c6c612f352e3020285831313b205562756e74753b204c696e7578207838365f36343b2072763a3132392e3029204765636b6f2f32303130303130312046697265666f782f3132392e300d0a4163636570743a202a2f2a0d0a4163636570742d4c616e67756167653a20656e2d55532c656e3b713d302e350d0a4163636570742d456e636f64696e673a20677a69702c206465666c6174652c2062722c207a7374640d0a526566657265723a20687474703a2f2f6c6f63616c686f73743a35323834372f0d0a436f6e6e656374696f6e3a206b6565702d616c6976650d0a436f6f6b69653a205f706b5f69642e322e316666663d353966343331626532303136396566332e313731373630313536392e3b205f706b5f69642e312e316666663d306261313033373862393362356238332e313731373631323234312e3b20706c756e64617574682d3d353439356562653035616264613961636633366130363733323138383866383133613366353366396461643739623330303032626435623764393036653533623b20435352462d546f6b656e2d35325241353d36507172555464506a5171416854515268725167434b754b6b35794172626b550d0a5365632d46657463682d446573743a20656d7074790d0a5365632d46657463682d4d6f64653a20636f72730d0a5365632d46657463682d536974653a2073616d652d6f726967696e0d0a5072696f726974793a20753d340d0a0d0a

; includes "hello world" body I shoved in.
= testPacket | x#0000000000000000000000000800450002886f6440004006bb097f0000017f000001800ace6f124ebb61a8099d2780180200007d00000101080a75b32e7e75b32db1474554202f6e6f746520485454502f312e310d0a486f73743a206c6f63616c686f73743a35323834370d0a557365722d4167656e743a204d6f7a696c6c612f352e3020285831313b205562756e74753b204c696e7578207838365f36343b2072763a3132392e3029204765636b6f2f32303130303130312046697265666f782f3132392e300d0a4163636570743a202a2f2a0d0a4163636570742d4c616e67756167653a20656e2d55532c656e3b713d302e350d0a4163636570742d456e636f64696e673a20677a69702c206465666c6174652c2062722c207a7374640d0a526566657265723a20687474703a2f2f6c6f63616c686f73743a35323834372f0d0a436f6e6e656374696f6e3a206b6565702d616c6976650d0a436f6f6b69653a205f706b5f69642e322e316666663d353966343331626532303136396566332e313731373630313536392e3b205f706b5f69642e312e316666663d306261313033373862393362356238332e313731373631323234312e3b20706c756e64617574682d3d353439356562653035616264613961636633366130363733323138383866383133613366353366396461643739623330303032626435623764393036653533623b20435352462d546f6b656e2d35325241353d36507172555464506a5171416854515268725167434b754b6b35794172626b550d0a5365632d46657463682d446573743a20656d7074790d0a5365632d46657463682d4d6f64653a20636f72730d0a5365632d46657463682d536974653a2073616d652d6f726967696e0d0a5072696f726974793a20753d340d0a0d0a68656c6c6f20776f726c64

= testPacketHTTPOnly | x#474554202f6e6f746520485454502f312e310d0a486f73743a206c6f63616c686f73743a35323834370d0a557365722d4167656e743a204d6f7a696c6c612f352e3020285831313b205562756e74753b204c696e7578207838365f36343b2072763a3132392e3029204765636b6f2f32303130303130312046697265666f782f3132392e300d0a4163636570743a202a2f2a0d0a4163636570742d4c616e67756167653a20656e2d55532c656e3b713d302e350d0a4163636570742d456e636f64696e673a20677a69702c206465666c6174652c2062722c207a7374640d0a526566657265723a20687474703a2f2f6c6f63616c686f73743a35323834372f0d0a436f6e6e656374696f6e3a206b6565702d616c6976650d0a436f6f6b69653a205f706b5f69642e322e316666663d353966343331626532303136396566332e313731373630313536392e3b205f706b5f69642e312e316666663d306261313033373862393362356238332e313731373631323234312e3b20706c756e64617574682d3d353439356562653035616264613961636633366130363733323138383866383133613366353366396461643739623330303032626435623764393036653533623b20435352462d546f6b656e2d35325241353d36507172555464506a5171416854515268725167434b754b6b35794172626b550d0a5365632d46657463682d446573743a20656d7074790d0a5365632d46657463682d4d6f64653a20636f72730d0a5365632d46657463682d536974653a2073616d652d6f726967696e0d0a5072696f726974793a20753d340d0a0d0a68656c6c6f20776f726c64

# typedef SenderIP Bar

# typedef ConnectionHandle Bar

; Includes a : between IP and port for legibility
> Bar > Nat > ConnectionHandle
= (bufferKey senderIP senderPort)
| barCat [senderIP b#{:} (natBar | showNat-senderPort)]

# record HTTPBuffer
| HTTP_BUF
* senderIP       : SenderIP
* senderPort     : Nat
* assembledData  : Bar
* headersParsed  : Bit
* headers        : (HMap Bar Bar)
* reqLineParsed  : Bit
* reqLine        : Bar
* contentLength  : Maybe Nat
* chunked        : Bit
* receivedLength : Nat

= (emptyBuffer senderIP senderPort)
| HTTP_BUF
* senderIP
* senderPort
* b#{}
* FALSE
* emptyTab
* FALSE
* b#{}
* NONE
* FALSE
* 0

# record CogState
| COG_STATE
* buffers    : (HMap ConnectionHandle HTTPBuffer)
* servThread : ThreadId

> ThreadId > CogState
= (newCogState servThread)
| COG_STATE
* emptyTab
* 0

= (modifyState vSt fun return)
: (PIN old) < readRef vSt
@ srv       | getServThread old
@ pNew      | PIN (fun old)
: _         < writeRef vSt pNew
; : _         < cancelFork srv (syscall (HTTP_SERV | fileServer pNew))
| return ()

= (corsHeaders)
[]

= testIP | b#{192.168.10.10}
= ipWord | ipToWord testIP

> Bar > Bar > List Int
= (barSubstringSearch needle haystack)
@ needleWidth   (barLen needle)
@ haystackWidth (barLen haystack)
| if (not needleWidth)
    | listTake haystackWidth (listEnumFrom 0)
@ firstByte     (barIdx 0 needle)
^ (_ 0)
? (go off)
@ found (barElemIndexOff firstByte off haystack)
| if (gte found haystackWidth) NIL
@ isMatch (barIsPrefixOf needle haystack found)
@ more    (go | inc found)
| if isMatch (CONS found more)
| else more

> Bar > Maybe Nat
= (findDoubleCRLF bar)
@ doubleCRLF x#0d0a
@ results (barSubstringSearch doubleCRLF bar)
| trk [%res results]
| listCase results
    NONE
& (firstMatch _)
| SOME firstMatch

> HTTPBuffer > HTTPBuffer
= (checkHeadersComplete buffer)
| trk [%checkHeaders ]
@ assembledData | getAssembledData buffer
| trk [%xxxAssembled getAssembledData assembledData buffer]
| maybeCase (findDoubleCRLF assembledData) buffer
& endIndex
| trk [%buffer buffer]
@ buffer | (setHeadersParsed TRUE buffer)
| trk [%bufferAfter buffer]
buffer

; TODO: need to update most other functions now in light of this new function.
;       proximate goal: extract headers.
> Bar > Bar > List Bar
= (barSubstringLinesList seek bar)
@ indices (barSubstringSearch seek bar)
@ seekLen (barLen seek)
@ wid (barLen bar)
^ listFilter (compose not barIsEmpty) _
^ _ 0 indices
? (go start idxList)
| listCase idxList
  | CONS (barSlice start (sub wid start) bar) NIL
& (idx rest)
| CONS (barSlice start (sub idx start) bar)
| go (add idx seekLen) rest

(barSubstringLines seek bar)=(listToRow | barSubstringLinesList seek bar)

=?= (listFromRow [x#de x#ad x#20be x#ef])
    | barSubstringLinesList x#0d x#{de0dad0d20be0def0d0d}

=?= [x#de x#ad x#20be x#ef]
    | barSubstringLines x#0d x#{de0dad0d20be0def0d0d}

=?= (listFromRow [x#de x#ad x#20be x#ee x#ef])
    | barSubstringLinesList x#0d x#{de0dad0d20be0dee0def}

=?= (listFromRow [x#de x#ad x#20be x#ef])
    | barSubstringLinesList x#0d x#{0d0dde0dad0d20be0def0d}

=?= (listFromRow [x#de x#ad x#200dbe x#ef])
    | barSubstringLinesList x#0d0a0d x#{de0d0a0dad0d0a0d200dbe0d0a0def0d0a0d}


;; \r\n\r\n
; (bytesBar [13 10 13 10])
;;

> Bar > (HMap Bar Bar)
= (extractHeaders headerBar)
@ newline | x#0d0a
@ headersAndBeyondL | (barLinesList headerBar)
@ justHeadersR | listToRow | listTakeWhile (neq x#0d0a) (listFromRow headersAndBeyondL)
| trk [%headerLines justHeadersR]
^ foldr _ emptyTab justHeadersR
& (line acc)
@ [key value] | barSplitOne 58 line
| trk [%kv key value]
@ trimmedKey | (barDropWhile (eql 32) key)
@ trimmedValue | (barDropWhile (eql 32) | barDrop 1 value)
@ idxTab | idx 0 (barSubstringSearch b#{\r} trimmedValue)
@ trimmedValue | (idx 0 (barSplitAt idxTab trimmedValue))
| tabIns trimmedKey trimmedValue acc

; = testBar | b#{GET /thing HTTP/1.1\nHost: example.com\r\nContent-Type: text/html\r\nContent-Length: 15\r\n\r\nHello, World!}
= testBar | x#474554202F7468696E6720485454502F312E310A486F73743A206578616D706C652E636F6D0A0A436F6E74656E742D547970653A20746578742F68746D6C0A436F6E74656E742D4C656E6774683A2031350A0A48656C6C6F2C20576F726C6421
= testBuffer | HTTP_BUF 9 8888 testBar FALSE emptyTab FALSE b#{} NONE FALSE 0

| findDoubleCRLF testBar

=?= (SOME 87) | (findDoubleCRLF testBar)

= testHeaderBar | x#486f73743a206578616d706c652e636f6d0d0a436f6e74656e742d547970653a20746578742f68746d6c0d0a436f6e74656e742d4c656e6774683a2031350d0a
= expectedHeaders | tabFromPairs [[b#Host b#{example.com}] [b#{Content-Type} b#{text/html}] [b#{Content-Length} b#15]]

=?= expectedHeaders | (extractHeaders testHeaderBar)

=?= TRUE | getHeadersParsed (checkHeadersComplete testBuffer)

= (findContentLength headers)
^ foldr _ NONE headers
& (header result)
@ [name value] | header
| if (eql name b#{Content-Length})
  | SOME (barLoadDecimal value)
result

; = (parseHeaders headerBar)
; @ headers (barSplit b#{\r\n} headerBar)
; ^ foldr _ [] headers
; & (header acc)
; @ [name value] (barSplitOne 58 header) ; 58 is ':'
; | CONS [name value] acc

; = testHeaders | b#{Host: www.example.com\r\nContent-Type: text/html\r\nContent-Length: 15\r\n}

; TODO: maybe pull out parseHeaders to use within extractHeaders later?
; =?= [[b#Host b#{www.example.com}] [b#{Content-Type} b#{text/html}] [b#{Content-Length} b#15]] | (parseHeaders testHeaders)

= (trimBar bar)
^ _ 0 (barLen bar)
? (loop start end)
| if (and (lth start end) (or (eql (barIdx start bar) 32) (eql (barIdx start bar) 9)))
  | loop (inc start) end
| if (and (gth end start) (or (eql (barIdx (dec end) bar) 32) (eql (barIdx (dec end) bar) 9)))
  | loop start (dec end)
| barSlice start (sub end start) bar

= (isChunked headers)
^ foldr _ FALSE headers
& (header result)
@ [name value] | header
| if (and (eql name b#{Transfer-Encoding}) (eql (trimBar value) b#{chunked}))
  TRUE
result

> Bar > Bar > Maybe Nat
= (getFirstIdxSubstring sought full)
@ l | barSubstringSearch sought full
| if (eql 0 l)
  NONE
| SOME (listIdx 0 l)

; YES, I realize this is an insane function.
; TODO: don't be insane.
> Bar > Bar > Maybe Nat
= (getSecondIdxSubstring sought full)
@ l | barSubstringSearch sought full
| if (eql 0 l)
  NONE
| SOME (listIdx 1 l)

=?= (0 2) | getFirstIdxSubstring b#x b#aaxaa

=?= (0 2) | getFirstIdxSubstring b#x b#aaxax

=?= (0 0) | getFirstIdxSubstring b#x b#xaaaa

=?= (0 4) | getFirstIdxSubstring b#x b#aaaax

=?= NONE | getFirstIdxSubstring b#x b#aaaaa

=?= (0 2) | getFirstIdxSubstring x#0d x#47470d4747

=?= (0 1) | getFirstIdxSubstring x#0d0a x#470d0a47

> Bar > Bar > HTTPBuffer
= (parseAndSetReqline stream buffer)
| if (getReqLineParsed buffer)
  ; already done, nothing to do.
  buffer
; do we have a first 0d0a?
; if not, just return buffer
| maybeCase (getFirstIdxSubstring x#0d0a stream) buffer
; if so, we have a reqline
& idx
; slice from here to the 0d0a
@ rl | barTake idx stream
; put that in reqline
@ buffer | setReqLine rl buffer
; mark it parsed
@ buffer | setReqLineParsed TRUE buffer
buffer

> Bar > Bar > HTTPBuffer
= (parseAndSetHeaders stream buffer)
| if | not (getReqLineParsed buffer)
  ; haven't even done request line yet, stop!
  buffer
; now request line is parsed, so we AT LEAST got the first x#0d0a...
; so we should wait until we have _all_ the headers, which is denoted by
; an empty line.
; TODO: find empty line
| maybeCase (getFirstIdxSubstring x#0d0a stream) buffer
; if so, we have a reqline
& rlIdx
; split at the request line and ignore it
@ [rl remain] | barSplitAt rlIdx stream
@ remainTrimmed | barDrop 2 remain
; Again, check to see if we have CRLF yet...
| maybeCase (getFirstIdxSubstring x#0d0a remainTrimmed) buffer
; if so, we have all the headers
& headersEndIdx
@ h | barTake headersEndIdx remainTrimmed
| trk [%zzzzzz remainTrimmed]
| die (extractHeaders remainTrimmed)
@ buffer | setHeaders h buffer
; TODO: use the good bits from extractHeaders here?
; mark it parsed
@ buffer | setHeadersParsed TRUE buffer
buffer

> Bar > Bit
= (validReqLine reqLine)
| if (eql reqLine 0)
  FALSE
@ split | listToRow | barSplit { } reqLine
| if (neq 3 (len split))
  ; we don't have three items
  FALSE
| if (any (x & (or (eql x 0) (eql 0 (barLen x)))) split)
  ; we have three, but some of them are empty?
  | die [split]
  FALSE
TRUE

> HTTPBuffer > Maybe Bar
= (mayExplainMethod buffer)
@ reqLine | getReqLine buffer
| if | not (validReqLine reqLine)
  NONE
@ [method uri protocol] | listToRow | barSplit { } reqLine
| SOME method

= testBuffer | HTTP_BUF 9 8888 testBar FALSE emptyTab FALSE b#{GET /foo HTTP/1.1} NONE FALSE 0

=?= (0 b#{GET}) | mayExplainMethod testBuffer

= testBuffer | HTTP_BUF 9 8888 testBar FALSE emptyTab FALSE b#{POST /foo HTTP/1.1} NONE FALSE 0

=?= (0 b#{POST}) | mayExplainMethod testBuffer

= testBuffer | HTTP_BUF 9 8888 testBar FALSE emptyTab FALSE b#{} NONE FALSE 0

=?= NONE | mayExplainMethod testBuffer

> HTTPBuffer > Maybe Bar
= (mayExplainUri buffer)
@ reqLine | getReqLine buffer
| if | not (validReqLine reqLine)
  NONE
@ [method uri protocol] | listToRow | barSplit { } reqLine
| SOME uri

= testBuffer | HTTP_BUF 9 8888 testBar FALSE emptyTab FALSE b#{GET /foo HTTP/1.1} NONE FALSE 0

=?= (0 b#{/foo}) | mayExplainUri testBuffer

= testBuffer | HTTP_BUF 9 8888 testBar FALSE emptyTab FALSE b#{asdfsadfsdf} NONE FALSE 0

=?= NONE | mayExplainUri testBuffer



; TODO: fucking up the buffer tab
= (processHttpChunk buffer chunk)
| trk [%processHttpChunk [buffer chunk]]
| trk [%xxxx buffer]
@ newAssembledData  | (barWeld (getAssembledData buffer) chunk)
@ newReceivedLength | (add (getReceivedLength buffer) | barLen chunk)
@ buffer | setAssembledData newAssembledData buffer
@ buffer | setReceivedLength newReceivedLength buffer
@ buffer | parseAndSetReqline newAssembledData buffer
@ buffer | parseAndSetHeaders newAssembledData buffer
buffer
; TODO: fuck all this shit:
; | if (not | (getHeadersParsed buffer))
;   | trk [%headersNotParsed]
;   | trk [%zzzzheaders (extractHeaders | barSlice 0 10000 newAssembledData)]
;   @ headerEnd | (findDoubleCRLF newAssembledData)
;   | trk [%zzzzheaderEnd headerEnd]
;   | maybeCase headerEnd buffer
;   & i
;   @ headers | (extractHeaders | barSlice 0 i newAssembledData)
;   | trk [%zzzzzzHeaders headers]
;   @ contentLength | (findContentLength headers)
;   | trk [%zzzzzzCL contentLength]
;   @ chunked | (isChunked headers)
;   @ buffer | setHeadersParsed TRUE buffer
;   @ buffer | setContentLength contentLength buffer
;   @ buffer | setChunked chunked buffer
;   buffer
; buffer

= (handleCompletedMessage buffer)
| trk [%completedMessage buffer]
| trk [%completedMessage (getAssembledData  buffer)]
; For testing fun:
| trk [%method (unpackSome-(mayExplainMethod buffer))]
| trk [%uri (unpackSome-(mayExplainUri buffer))]
| trk [%headers (getHeaders buffer)]
| emptyBuffer 555 333

; TODO: might need to make sure this is counting properly, given size of bytes?
> Bar > Bar > Bit
= (byteAtEnd sought full)
; @ sought   | x#0d0a0d0a
@ hits       | barSubstringSearch sought full
| trk [%hits hits]
| if (isZero hits)
  | trk [%isZero]
  FALSE
@ lastHitIdx | listIdx (dec | listLen hits) hits
| trk [%lastHitIdx lastHitIdx]
; @ soughtLen  | mul 4 (barLen sought))
@ soughtLen  | barLen sought
| trk [%soughtLen soughtLen]
@ total      | barLen full
| trk [%total total]
; have a sought byte index
; and that index is properly at the end of the entire message
| trk [%sub (sub total lastHitIdx)]
| trk [%inc (inc (sub total lastHitIdx))]
| trk [%soughtLen soughtLen]
| trk [%gth (gth lastHitIdx 0)]
| and (gth lastHitIdx 0) (eql soughtLen (sub total lastHitIdx))

= findMe | x#0a0a
= within | x#0d0d0d0a0a

=?= TRUE | (byteAtEnd findMe within)

= findMe | x#0a
= within | x#0d0d0d0a

=?= TRUE | (byteAtEnd findMe within)

= findMe | x#0a
= within | x#0d0a0d0d0a

=?= TRUE | (byteAtEnd findMe within)

= findMe | x#0a
= within | x#0d0d0d0d

=?= FALSE | (byteAtEnd findMe within)

> HTTPBuffer > Bit
= (isMessageComplete buffer)
; TODO: short-circuiting to handle headers before dealing with the notes below.
; For now, just looking for "double crlf" at end of message
| not | isZero | idx 0 | barSubstringSearch x#0d0a0d0a (getAssembledData buffer)
;
;
; Various ways a message can be inferred to be complete in HTTP 1.0...
; - if no body is present, the end of the headers (blank line) signifies end
; - if body is present...
;   - `Connection: close` header
;     - might have to wait around for this... when to stop waiting?
;   - `Content-Length` header
;| trk [%checkIsComplete buffer]
;@ chunkedFlag | x#0d0a30d0a0d0a
;@ message     | getAssembledData buffer
;@ idx | barSubstringSearch x#0d0a0d0a message
;| trk [%idx idx]
;| trk [%isChunked (getChunked buffer)]
;| if (getChunked buffer)
;  ;; x#0d0a30d0a0d0a - should be end bytes for chunked
;  | byteAtEnd chunkedFlag message
;| trk [%notSuffix]
;| trk [%contentLength (getContentLength buffer)]
;| maybeCase (getContentLength buffer) | FALSE
;& expectedLength
;| trk [%gteThings]
;| trk [%expectedLength expectedLength]
;| gte (getReceivedLength buffer) expectedLength

= (processConnection in buffer return)
: data < syscall | TCP_TAKE in
| if (barIsEmpty data) ; check to see if we're done with HTTP message | trk [%connectionClosed]
  ;| emptyBuffer (TODO: maybe?)
  | todo [%gotEmptyData buffer]
  | return ()
@ updatedBuffer | processHttpChunk buffer data
| trk [%updatedBuffer updatedBuffer]
| if (isMessageComplete updatedBuffer)
  | trk [%processConnectionDone]
  @ newBuffer | handleCompletedMessage updatedBuffer
  | processConnection in newBuffer
| trk [%processConnectionRecurring]
| processConnection in updatedBuffer return

= (serverLoop return)
; - processConnection needs to work continuously until it has a complete message
; - then ... forward this whole thing away?
;   - or make available to a consumer or something
; create a connection handle:
;
; WHEN YOU HIT A SYSCALL YOU'RE ALWAYS DONE, THREAD-WISE
; (but the cog isn't finished because you forked)
; (add TCP_HEAR to rq row, at the *end* of the event), then continue with k
;;;; the stack of syscalls is the "events" in the kernel loop stream
;;;; and the sl and rq is the stack of continuations for those syscalls
;;;; "exe" is the continuation and "response" is the result from the runtime (kern.sire KERNEL function)
;;;; "end" is "return"
;
; todo: we'll need "infinite of these" / re-create when done / maybe forward on to
;       next port number forever?
: [in ip port]   < syscall | TCP_HEAR
; TODO: ip to word
; ip and port from who connected to us.
| trk [=in]
: tid < fork (serverLoop)
| processConnection in (emptyBuffer ipWord 8888) return

= main
: exit < runCog
; open a connection for the sake of hydrating with some test packet data
: mout < syscall | TCP_OPEN ipWord 9999
| trk [=mout]
: out  < maybeCase mout | exit ()
| trk [=out]
: gave < syscall | TCP_GIVE out testPacketHTTPOnly
| trk [=gave]
; now we're done setting up the test data
;
| serverLoop exit


