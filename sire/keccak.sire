#### keccak <- quickcheck

:| sire
:| quickcheck 

> Nat > Nat
= (log2floor n)
| if (lte n 1) | 0
| inc | log2floor | rsh n 1

> Nat > Bit
= (isPow2 n)
| and n
| isZero | con n dec-n

> Nat > Nat
= (log2ceil n)
| if (lte 2 1)  | 0
| if (isPow2 n) | log2floor n
| else          | inc | log2floor n

; We need a special function for this since we only have nats
> Nat > Nat > Nat
= (subMod p x y)
^ mod (sub _ y) p
| if (lte y x) | x
| else         | add x p

= (addMod p a b) | mod (add a b) p

> Row Row-Nat
= rotationOffsets
++ [0 36 3 41 18]
++ [1 44 10 45 2]
++ [62 6 43 15 61]
++ [28 55 25 21 56]
++ [27 20 39 8 14]

= (hh x y)
| eql x
| barNat y

= afterPi
++ , 0x0000700000600487 0x18C8900002300102 0x0030300003800101 0x2002083081800004 0x08800C0042C14000
++ , 0x00041840D0000210 0x20030210B0100002 0x0003800003042030 0x3191200000600200 0x40000E20040400C0
++ , 0x0000260020031912 0x001C000808018180 0x0000830C1C000042 0x00220030010B0100 0xC400018210100001
++ , 0x01800C5808000190 0x0608404000070000 0x000C0040063A2400 0x3800101001030000 0x0C00002100004184
++ , 0x80001C0008082181 0x06000000800020C2 0x0085808000110018 0xC100080000E00020 0x00000C0040063224

= afterChi
++ , 0x0030500001E00486 0x38CA983082300106 0x08B0340041C14101 0x2002783081A00483 0x10488C0040D14100
++ , 0x00049840D3042220 0x11932210B0700202 0x40038E20070020F0 0x31953040D0600010 0x60030C30241400C2
++ , 0x0000A50434031950 0x003E0038090A8080 0xC400828E0C100043 0x0022263021081812 0xC41C018A18108081
++ , 0x01840C580E382590 0x3E08505001060000 0x040C0061063A6584 0x39801C4809030010 0x0A08402100074184
++ , 0x80859C8008192199 0xC700080080E020E2 0x008584804017321C 0x4100180008E801A1 0x06000C00C0063266

> Row Word64
= roundConstants
, 0x0000000000000001 0x0000000000008082 0x800000000000808a
  0x8000000080008000 0x000000000000808b 0x0000000080000001
  0x8000000080008081 0x8000000000008009 0x000000000000008a
  0x0000000000000088 0x0000000080008009 0x000000008000000a
  0x000000008000808b 0x800000000000008b 0x8000000000008089
  0x8000000000008003 0x8000000000008002 0x8000000000000080
  0x000000000000800a 0x800000008000000a 0x8000000080008081
  0x8000000000008080 0x0000000080000001 0x8000000080008008

# record PermutationWidth | PERMUTATIONWIDTH b:Nat w:Nat n:Nat

= (mkPermWidth b)
@ w | div b 25
@ n | add 12 | mul 2 | log2floor w
| PERMUTATIONWIDTH b w n 

= _25   | mkPermWidth 25
= _50   | mkPermWidth 50
= _100  | mkPermWidth 100
= _200  | mkPermWidth 200
= _400  | mkPermWidth 400
= _800  | mkPermWidth 800
= _1600 | mkPermWidth 1600

# typedef StateArray (Row Row-Nat)


= (rotate w n r)
| if (r == w) | n
@ shift | subMod-w w r
| dis | rsh n shift
^ lsh _ r
| bitSlice 0 shift n

=?= 2   | rotate 8 1 1
=?= 1   | rotate 8 128 1
=?= 255 | rotate 8 255 1
=?= 240 | rotate 8 15 4
=?= 85  | rotate 8 170 3
=?= 3   | rotate 8 192 2
=?= 170 | rotate 8 85 7

; TODO profile this. Might be more efficient to get the row in one step and then get the element in the next.
> StateArray > Nat > Nat
= (lane A x y)
@ x | mod x 5
@ y | mod y 5
| idx y | idx x A

= piMapping
| map fst
| sortOn (compose rev snd)
| cat
: y < gen 5
: x < gen 5
((x, y), (y, mod (add (mul 2 x) (mul 3 y)) 5))

= (bar r)
^ [fake=_ real=(map (map natBar) r)]
: x < gen 5
: y < gen 5
| natBar | lane r y x

; Pairwise binary operation on two equally sized matrices.
> (a > b > c) > Row Row-a > Row Row-b > Row Row-c
= (zipWith2D f) | zipWith (zipWith f)

; This closely follows https://keccak.team/keccak_specs_summary.html
> PermutationWidth > StateArray > StateArray
= (keccakF [b w n] A)
@ (comp x) ^ trk [x=x result=_ sub=sub something=(gte (dec bex-w) x) dec=dec bex=bex w=w bex_w=(bex w) dec_bex_w=(dec bex-w) sub_dec_bex_w_x=(sub (dec bex-w) x)] _
           | sub (dec bex-w) x ; bit complement
@ inc     | addMod-5 1
@ (dec x) | subMod-5 x 1
@ rot     | rotate w
@ offsets | map (map | flip mod w) rotationOffsets
| trk [rho_offsets=offsets]
@ RCs | gen n (i & mod (idx i roundConstants) bex-w)
| trk [RCs=RCs]
^ snd | foldl _ (0,A) RCs
& ((i,A) RC)
| trk [round=i RC=(natBar RC)]
; theta
@ C | foreach A | foldr1 mix
@ D : x < gen 5
    | mix | get C dec-x
    | rot (get C inc-x) 1
@ A : x < gen 5
    | map (mix | get D x) (get A x)
| trk [after_theta=(bar A)]
; rho
@ B | zipWith2D rot A offsets
| trk [after_rho=(bar B)]
; pi
@ B | chunks 5 | map (uncurry lane-B) piMapping
| trk [after_pi=(bar B)]
; chi
@ A @ (mix_ x y) | trk ['xor_of [Bxy=(natBar x) other=(natBar y)]] | mix x y
    @ (comp_ x)  | trk [comp_of=(natBar x)] | comp x
    @ (con_ x y) | trk ['con_of [Bx1y_comp=(natBar y) Bx2y=(natBar x)]] | con x y
    @ B1 | gen 5 (i & get B inc-i)
    @ B2 | gen 5 (i & get B (addMod-5 i 2))
    | if (i == 2) (trk [B1=(bar B1) B2=(bar B2)]) id
    | zipWith2D mix_ B
    | zipWith2D con_ B2
    | map (map comp_) B1
| trk [after_chi=(bar A)]
; iota
| v2 (add i 1)
^ trk [after_iota=(bar _)] _
@ A0 | get A 0
| put A 0 | put A0 0 | mix RC | get A0 0


= emptyArray | chunks 5 | rep 0 25

= (test l)
| keccakF l
| chunks 5 | rep 0 25

= (test2 l)
| keccakF l
| keccakF l
| chunks 5 | rep 0 25

; Test cases from
; https://github.com/XKCP/XKCP/blob/4017707cade3c1fd42f3c6fa984609db87606700/tests/TestVectors

= (transpose r)
: x < gen 5
: y < gen 5
| lane r y x

=?= | keccakF _200 emptyArray
  | transpose
  ++ , 0x3C 0x28 0x26 0x84 0x1C
  ++ , 0xB3 0x5C 0x17 0x1E 0xAA
  ++ , 0xE9 0xB8 0x11 0x13 0x4C
  ++ , 0xEA 0xA3 0x85 0x2C 0x69
  ++ , 0xD2 0xC5 0xAB 0xAF 0xEA

=?= | keccakF _200 | keccakF _200 emptyArray
  | transpose
  ++ , 0x1B 0xEF 0x68 0x94 0x92
  ++ , 0xA8 0xA5 0x43 0xA5 0x99
  ++ , 0x9F 0xDB 0x83 0x4E 0x31
  ++ , 0x66 0xA1 0x4B 0xE8 0x27
  ++ , 0xD9 0x50 0x40 0x47 0x9E

=?= | keccakF _400 emptyArray
  | transpose
  ++ , 0x09F5 0x40AC 0x0FA9 0x14F5 0xE89F
  ++ , 0xECA0 0x5BD1 0x7870 0xEFF0 0xBF8F
  ++ , 0x0337 0x6052 0xDC75 0x0EC9 0xE776
  ++ , 0x5246 0x59A1 0x5D81 0x6D95 0x6E14
  ++ , 0x633E 0x58EE 0x71FF 0x714C 0xB38E

=?= | keccakF _400 | keccakF _400 emptyArray
  | transpose
  ++ , 0xE537 0xD5D6 0xDBE7 0xAAF3 0x9BC7
  ++ , 0xCA7D 0x86B2 0xFDEC 0x692C 0x4E5B
  ++ , 0x67B1 0x15AD 0xA7F7 0xA66F 0x67FF
  ++ , 0x3F8A 0x2F99 0xE2C2 0x656B 0x5F31
  ++ , 0x5BA6 0xCA29 0xC224 0xB85C 0x097C

=?= | keccakF _800 emptyArray
  | transpose
  ++ , 0xE531D45D 0xF404C6FB 0x23A0BF99 0xF1F8452F 0x51FFD042
  ++ , 0xE539F578 0xF00B80A7 0xAF973664 0xBF5AF34C 0x227A2424
  ++ , 0x88172715 0x9F685884 0xB15CD054 0x1BF4FC0E 0x6166FA91
  ++ , 0x1A9E599A 0xA3970A1F 0xAB659687 0xAFAB8D68 0xE74B1015
  ++ , 0x34001A98 0x4119EFF3 0x930A0E76 0x87B28070 0x11EFE996

=?= | keccakF _800 | keccakF _800 emptyArray
  | transpose
  ++ , 0x75BF2D0D 0x9B610E89 0xC826AF40 0x64CD84AB 0xF905BDD6
  ++ , 0xBC832835 0x5F8001B9 0x15662CCE 0x8E38C95E 0x701FE543
  ++ , 0x1B544380 0x89ACDEFF 0x51EDB5DE 0x0E9702D9 0x6C19AA16
  ++ , 0xA2913EEE 0x60754E9A 0x9819063C 0xF4709254 0xD09F9084
  ++ , 0x772DA259 0x1DB35DF7 0x5AA60162 0x358825D5 0xB3783BAB

; =?= | keccakF _1600 emptyArray
;   | transpose
;   ++ , 0xF1258F7940E1DDE7 0x84D5CCF933C0478A 0xD598261EA65AA9EE 0xBD1547306F80494D 0x8B284E056253D057
;   ++ , 0xFF97A42D7F8E6FD4 0x90FEE5A0A44647C4 0x8C5BDA0CD6192E76 0xAD30A6F71B19059C 0x30935AB7D08FFC64
;   ++ , 0xEB5AA93F2317D635 0xA9A6E6260D712103 0x81A57C16DBCF555F 0x43B831CD0347C826 0x01F22F1A11A5569F
;   ++ , 0x05E5635A21D9AE61 0x64BEFEF28CC970F2 0x613670957BC46611 0xB87C5A554FD00ECB 0x8C3EE88A1CCF32C8
;   ++ , 0x940C7922AE3A2614 0x1841F924A2C509E4 0x16F53526E70465C2 0x75F644E97F30A13B 0xEAF1FF7B5CECA249
; 
; =?= | keccakF _1600 | keccakF _1600 emptyArray
;   | transpose
;   ++ , 0x2D5C954DF96ECB3C 0x6A332CD07057B56D 0x093D8D1270D76B6C 0x8A20D9B25569D094 0x4F9C4F99E5E7F156
;   ++ , 0xF957B9A2DA65FB38 0x85773DAE1275AF0D 0xFAF4F247C3D810F7 0x1F1B9EE6F79A8759 0xE4FECC0FEE98B425
;   ++ , 0x68CE61B6B9CE68A1 0xDEEA66C4BA8F974F 0x33C43D836EAFB1F5 0xE00654042719DBD9 0x7CF8A9F009831265
;   ++ , 0xFD5449A6BF174743 0x97DDAD33D8994B40 0x48EAD5FC5D0BE774 0xE3B8C8EE55B7B03C 0x91A0226E649E42E9
;   ++ , 0x900E3129E7BADD7B 0x202A9EC5FAA3CCE8 0x5B3402464E1C3DB6 0x609F4E62A44C1059 0x20D06CD26A8FBF5C

= (keccak256 msg) 'result
