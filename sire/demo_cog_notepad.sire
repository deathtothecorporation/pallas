;;; Copyright 2024 OPfN
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.
;;

; Usage:
; 1. start cog, note port.
; 2. curl localhost:<port>/note
;    - see that you get a { "note": "some text here" } JSON response
; 3. curl -v localhost:<port>/changed -H "Content-Type: application/json" -d '{"newNote":"new note content here"}'
;   - see that you get a JSON response with the updated note

#### demo_cog_notepad <- proc_http

:| proc_http
:| json

; TODO:
; templating fileserver.
; separate patterns for static assets vs state requests

# typedef ContentType Bar

> HMap Str (ContentType, Pin Bar)
= startingFiles
| hmSingleton
* largeConfig

# record CogState
| COG_STATE
* note       : Nat
* files      : (HMap Str (ContentType, Pin Bar))
* fileBytes  : Nat

> Nat > CogState
= (newCogState)
| COG_STATE
* b#{# Pallas Notepad\n\n- Any text entered here will be saved to Pallas.\n- Feel free to delete all of this intial content.\n\n**Enjoy!**}
* startingFiles
* 0

(bindMaybe mVal k)=(maybeCase mVal NONE k)

> Bar > Maybe (Tab Str Json)
= (jsonMap jsonBS)
@ res@[json leftover] (parseJson jsonBS)
| if (res || leftover) NONE
# datacase json
* JMAP|m | SOME m
* _      | NONE

= (asJsonStr m)
# datacase m
* JSTR|s | SOME s
* _      | NONE

= (asJsonNum m)
# datacase m
* JNUM|n | SOME n
* _      | NONE

= (parseNote jsonBS)
@ res@[json leftover] (parseJson jsonBS)
| trk [%parseNote jsonBS]
: string < bindMaybe (asJsonStr json)
| SOME string

= (parseNoteJson jsonBS)
: map < bindMaybe (jsonMap jsonBS)
: theNote < bindMaybe (tabLookup %newNote map)
| SOME (barNat theNote)

(msgToStr m)=(JSTR | natBar m)

= (buildNoteJson note)
| JMAP
## =note | JVEC note

= (buildJson st)
@ COG_STATE(..) st
| JMAP
## =note  | JVEC note
## =files | JVEC (map msgToStr (idx 0 (hmKeys files))) ; row-in-row for some reason
## =totalSize | JNUM fileBytes ; this is structured wrong ?

= corsHeaders | [(b#{Access-Control-Allow-Origin}, b#{*}) (b#{Access-Control-Allow-Methods}, b#{PUT, GET, POST, DELETE, OPTIONS}) (b#{Access-Control-Allow-Headers}, b#{*}) (b#{Access-Control-Allow-Credentials}, b#{true})]

= htmlStart
# b
} <!DOCTYPE html>
} <html lang="en">
}   <head>
}     <meta charset="UTF-8" />
}     <meta name="viewport" content="width=device-width, initial-scale=1.0" />
}     <title>notepad</title>
}     <script
}       src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"
}       defer
}     ></script>
}     <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
}     <style>
}       body {
}         font-family: Arial, sans-serif;
}         max-width: 1200px;
}         margin: 0 auto;
}         padding: 20px;
}       }
}       .editor-container {
}         display: flex;
}         gap: 20px;
}       }
}       #editor,
}       #preview {
}         width: 50%;
}         height: 400px;
}         border: 1px solid #ccc;
}         padding: 10px;
}         overflow-y: auto;
}       }
}       #preview {
}         height: 90vw;
}       }
}       #editor {
}         resize: vertical;
}       }
}       #status {
}         font-style: italic;
}         opacity: 0.25;
}         margin-top: 10px;
}       }
}       .port-input {
}         margin-bottom: 10px;
}       }
}       #context-menu {
}         position: absolute;
}         background-color: #f9f9f9;
}         border: 1px solid #ccc;
}         padding: 5px;
}         z-index: 1000;
}       }
}       #context-menu a {
}         display: block;
}         padding: 5px;
}         text-decoration: none;
}         color: #333;
}       }
}       #context-menu a:hover {
}         background-color: #e9e9e9;
}       }
}       .context-menu-section {
}         border-top: 1px solid #ccc;
}         margin-top: 5px;
}         padding-top: 5px;
}       }
}       .context-menu-section:first-child {
}         border-top: none;
}         margin-top: 0;
}         padding-top: 0;
}       }
}       .context-menu-footer {
}         border-top: 1px solid #ccc;
}         margin-top: 5px;
}         padding-top: 5px;
}       }
} 
}       /* Basic Markdown Styles for preview */
}       #preview h1,
}       #preview h2,
}       #preview h3 {
}         margin-top: 0;
}       }
}       #preview strong {
}         font-weight: bold;
}       }
}       #preview em {
}         font-style: italic;
}       }
}       #preview ul,
}       #preview ol {
}         padding-left: 20px;
}       }
}       #preview code {
}         background-color: #f0f0f0;
}         padding: 2px 4px;
}         border-radius: 3px;
}       }
}       #preview img {
}         max-width: 100%;
}         height: auto;
}       }
}     </style>
}   </head>
}   <body>
}     <div x-data="notepad">
}       <div class="port-input" x-show="!isConnected">
}         <label for="port">Enter Port:</label>
}         <input type="number" id="port" x-model="port" @input="validatePort" />
}         <button @click="initializeApp" :disabled="!isPortValid">Connect</button>
}       </div>
}       <div class="editor-container">
}         <textarea
}           id="editor"
}           x-model="noteText"
}           @input="updateNote"
}           x-ref="editor"
}           @contextmenu.prevent="showContextMenu"
}         ></textarea>
}         <div id="preview" x-html="renderedMarkdown"></div>
}       </div>
}       <div id="status" x-text="status"></div>
} 
}       <div
}         id="context-menu"
}         x-show="showMenu"
}         :style="{ top: menuY + 'px', left: menuX + 'px' }"
}       >
}         <div class="context-menu-section">
}           <a href="#" @click.prevent="triggerFileUpload">Upload a file</a>
}         </div>
}         <div class="context-menu-section" x-show="files.length > 0">
}           <template x-for="file in files">
}             <a
}               href="#"
}               @click.prevent="insertExistingFileLink(file)"
}               x-text="file"
}             ></a>
}           </template>
}         </div>
}         <div class="context-menu-footer">
}           <a href="#" @click.prevent="hideContextMenu">Cancel</a>
}         </div>
}       </div>
}       <input
}         type="file"
}         x-ref="fileInput"
}         @change="uploadFile"
}         style="display: none"
}       />
}     </div>
}     <script>
}       document.addEventListener("alpine:init", () => {
}         Alpine.data("notepad", () => ({
}           noteText: "",
}           renderedMarkdown: "",
}           status: "",
}           debounceTimer: null,

= htmlEnd
# b
}           filePort: "",
}           isPortValid: false,
}           isConnected: false,
}           showMenu: false,
}           menuX: 0,
}           menuY: 0,
}           files: [],
} 
}           init() {
}             this.validatePort();
}             this.initializeApp();
}           },
} 
}           validatePort() {
}             this.isPortValid =
}               this.port.trim() !== "" &&
}               !isNaN(this.port) &&
}               this.port > 0 &&
}               this.port < 65536;
}           },
} 
}           initializeApp() {
}             if (this.isPortValid) {
}               this.isConnected = true;
}               this.fetchNote();
}               // TODO: no files for now
}               // this.fetchFiles();
}             }
}           },
} 
}           fetchNote() {
}             if (!this.isConnected) return;
} 
}             fetch(`http://localhost:${this.port}/note`)
}               .then((response) => response.text())
}               .then((text) => {
}                 try {
}                   const data = JSON.parse(text);
}                   this.noteText = data.note;
}                   this.renderMarkdown();
}                   this.status = "Note loaded";
}                   setTimeout(() => {
}                     this.status = "";
}                   }, 2000);
}                 } catch (e) {
}                   console.error("Error parsing JSON:", e);
}                   this.status = "Error parsing note data";
}                 }
}               })
}               .catch((error) => {
}                 console.error("Error fetching note:", error);
}                 this.status = "Error loading note";
}               });
}           },
} 
}           updateNote() {
}             if (!this.isConnected) return;
} 
}             this.renderMarkdown();
} 
}             clearTimeout(this.debounceTimer);
} 
}             this.debounceTimer = setTimeout(() => {
}               this.status = "Saving...";
}               this.saveNote();
}             }, 1000);
}           },
} 
}           saveNote() {
}             if (!this.isConnected) return;
} 
}             fetch(`http://localhost:${this.port}/changed`, {
}               method: "POST",
}               headers: {
}                 "Content-Type": "application/json",
}               },
}               body: JSON.stringify({ newNote: this.noteText }),
}             })
}               .then((response) => {
}                 if (response.ok) {
}                   this.status = "Saved!";
}                   setTimeout(() => {
}                     this.status = "";
}                   }, 2000);
}                 } else {
}                   this.status = "Error saving";
}                 }
}               })
}               .catch((error) => {
}                 console.error("Error saving note:", error);
}                 this.status = "Error saving";
}               });
}           },
} 
}           renderMarkdown() {
}             this.renderedMarkdown = marked.parse(this.noteText);
}           },
} 
}           showContextMenu(event) {
}             this.menuX = event.clientX;
}             this.menuY = event.clientY;
}             this.showMenu = true;
}             // TODO: no files for now
}             // this.fetchFiles();
}           },
} 
}           hideContextMenu() {
}             this.showMenu = false;
}           },
} 
}           triggerFileUpload() {
}             this.hideContextMenu();
}             this.$refs.fileInput.click();
}           },
} 
}           uploadFile(event) {
}             const file = event.target.files[0];
}             if (!file) return;
} 
}             const formData = new FormData();
}             formData.append("file", file);
} 
}             fetch(`http://localhost:${this.filePort}/${file.name}`, {
}               method: "POST",
}               body: file,
}               headers: {
}                 "Content-Type": file.type,
}               },
}             })
}               .then((response) => {
}                 if (response.ok) {
}                   this.status = "File uploaded successfully";
}                   this.insertFileLink(file.name, file.type);
}                   // TODO: no files for now
}                   // this.fetchFiles();
}                 } else {
}                   throw new Error("Upload failed");
}                 }
}               })
}               .catch((error) => {
}                 console.error("Error uploading file:", error);
}                 this.status = "Error uploading file";
}               });
}           },
} 
}           fetchFiles() {
}             fetch(`http://localhost:${this.filePort}/files`)
}               .then((response) => response.text())
}               .then((text) => {
}                 try {
}                   const data = JSON.parse(text);
}                   this.files = data.files;
}                   this.status = "Files loaded";
}                   setTimeout(() => {
}                     this.status = "";
}                   }, 2000);
}                 } catch (e) {
}                   console.error("Error parsing JSON:", e);
}                   this.status = "Error parsing files data";
}                 }
}               })
}               .catch((error) => {
}                 console.error("Error fetching files:", error);
}                 this.status = "Error loading files";
}               });
}           },
} 
}           insertExistingFileLink(filename) {
}             this.hideContextMenu();
}             this.insertFileLink(filename);
}           },
} 
}           insertFileLink(filename, filetype) {
}             if (filename.startsWith("/")) {
}               filename = filename.slice(1);
}             } else {
}               filename = filename;
}             }
} 
}             const link = `http://localhost:${this.filePort}/${filename}`;
} 
}             if (!filetype) {
}               const extension = filename.split(".").pop().toLowerCase();
}               const imageExtensions = [
}                 "jpg",
}                 "jpeg",
}                 "png",
}                 "gif",
}                 "bmp",
}                 "svg",
}               ];
}               filetype = imageExtensions.includes(extension)
}                 ? "image/"
}                 : "application/";
}             }
} 
}             if (filetype.startsWith("image/")) {
}               markdownLink = `![${filename}](${link})`;
}             } else {
}               markdownLink = `[${filename}](${link})`;
}             }
} 
}             // Insert the link at the current cursor position
}             const textarea = this.$refs.editor;
}             const cursorPos = textarea.selectionStart;
}             const textBefore = this.noteText.substring(0, cursorPos);
}             const textAfter = this.noteText.substring(cursorPos);
}             this.noteText = textBefore + markdownLink + textAfter;
} 
}             // Update the preview
}             this.renderMarkdown();
} 
}             // Set cursor position after the inserted link
}             this.$nextTick(() => {
}               textarea.focus();
}               textarea.setSelectionRange(
}                 cursorPos + markdownLink.length,
}                 cursorPos + markdownLink.length
}               );
}             });
} 
}             this.saveNote();
}           },
}         }));
}       });
}     </script>
}   </body>
} </html>

= (interpolatePort port)
| barCat
@ pre | barCat
      , b#{        port: "}
        (natBar (showNat port))
        b#{",}
| intersperse barNewline [pre b#{}]

= (interpolateIndex port)
| barCat [htmlStart (interpolatePort port) htmlEnd]

# typedef HTTPRequest Any

# typedef HTTPResponse Any

# typedef Cog Any

# typedef Proc Any

# typedef Query | Any

# typedef Command | Any


; TODO:
; > HTTPRequest > Cog (Tab Bar Bar, Bar, Nat, Bar)
= (writeHandler httpRequest return)
: st < state
| trk [%writeHandlerCalled [=httpRequest]]
| trk [%hasState [=st]]
@ requestedBody | getReqBody   httpRequest
@ requestedPath | getReqPath   httpRequest
@ requestedMeth | getReqMethod httpRequest
;
| trk [%body [=requestedBody]]
| trk [%path [=requestedPath]]
| trk [%method [=requestedMeth]]
# switch requestedPath
* b#{/changed}
  | trk [%atChangedNote]
  ; TODO: feels like this should live elsewhere
  @ priorNote | getNote st
  @ noteNat   | fromSome priorNote | parseNoteJson requestedBody
  @ note      | natBar noteNat
  @ newState  | setNote note st
  : _ < write newState
  | return newState
* _
  | trk [%xxxxfallback]
  | const b#{error}

# typedef Method | Bar

> HTTPRequest > Method
= (getMethod httpRequest)
; TODO: do we need to handle failures here?
| getReqMethod httpRequest

= (respondWithStatic static state)
static

> HTTPRequest > Query
= (buildQuery httpRequest)
@ requestedBody | getReqBody   httpRequest
@ requestedPath | getReqPath   httpRequest
@ requestedMeth | getReqMethod httpRequest
| trk [%buildQuery [=httpRequest]]
| trk [%body [=requestedBody]]
| trk [%path [=requestedPath]]
| trk [%method [=requestedMeth]]
# switch requestedPath
* b#{/note}
  | trk [%atNote]
  [b#noteGet getNote]
* b#{/}
  | trk [%atSlash]
  @ headers    | getReqHeader httpRequest
  @ hostHeader | tabGet headers b#{Host}
  @ port | unpackSome | parseNat | idx 1 | listToRow | barSplit {:} hostHeader
  | trk [%hgostHeader hostHeader]
  | trk [%port port]
  @ indexPage | interpolateIndex port
  | trk [=indexPage]
  [b#index (respondWithStatic indexPage)]
  ; [b#index indexPage]
* _
  | trk [%xxxxfallback]
  | const b#{error}

; Whatever function we pass here for "Query" will be called against state.
> CogState > Nat > Query > HTTPResponse
; "reads" is part of the cog public state. the runtime will inject
; state, procId and query
= (reads state procId query)
; ignore procId, we only have the one proc_http atm
| query state


; TODO;
> Any > (Tab Bar Bar, Bar, Nat, Bar)
; What shape will the cog return from its read?
= (formulateResponse [shape someData])
| trk [=someData]
| trk [=shape]
| if (eql someData b#{error}) ; from the path switch
  @ headers | emptyTab
  @ body    | b#{}
  @ code    | 404
  @ reas    | b#{Not found}
  [headers body code reas]
# switch shape
* b#index
  @ corsHeaderT | tabFromPairs corsHeaders
  @ headers | tabIns b#{Content-Type} b#{text/html} corsHeaderT
  @ body    | someData
  @ code    | 200
  @ reas    | b#{OK}
  [headers body code reas]
* _
  ; TODO: how would formulateResponse know _what_ kind of response it has?
  ; - an html template?
  ; - a cog record, which needs to be JSON'ed?
  ;
  ; We probably want this formulator to be pretty "dumb"? maybe it should receive
  ; the body and content type and just be responsible for sort of putting it together?
  ; **types** / head-tagged unions would be one urbity way to handle this?
  ;
  ;----
  ;
  ; This assumes we'll _only ever have notes_, which is true for now but not always.
  @ noteJson    | buildNoteJson someData
  @ noteJsonBS  | printJson noteJson
  @ corsHeaderT | tabFromPairs corsHeaders
  @ headers | tabIns b#{Content-Type} b#{application/json} corsHeaderT
  @ body    | noteJsonBS
  ; @ body    | b#{""}
  @ code    | 200
  @ reas    | b#{OK}
  [headers body code reas]

; TODO:
; - what about requests for "static assets", like favicon.ico? index.html?
;   we're sort of mixing the "controller" and "view" responsibilities here.
; > HTTPRequest > Proc HTTPResponse
= (requestHandler msg return)
; This is a proc, go wild.
: port < syscall | TCP_MINE
| trk [%requestHandler [=msg]]
# switch (getMethod msg)
    ; TODO: how should we handle crashes?
    ; at the moment, the cog gets into a bad state forever.
* _
  | trk {unknown method}
  | return (formulateResponse [b#empty b#{}])
* b#GET
  @ [shape query] | buildQuery msg
  | trk [%ReqHandlerQuery query]
  : gotRes < syscall | DB_READ | query
  | trk [%ReqHandlerGotRes gotRes]
  | trk [%ReqHandlerShape shape]
  | return (formulateResponse [shape gotRes])
* b#POST
  : newState < tag_syscall | DB_WRITE | msg
  | trk [%wrote newState]
  ; TODO: once again assuming "this is only ever about notes". fine for now
  @ noteState | getNote newState
  | trk [%sending (formulateResponse [b#noteState noteState])]
  | return (formulateResponse [b#noteState noteState])
* b#HEAD
  ; if this should even be here...
  | return (formulateResponse [b#empty b#{}])

= (newHttp return)
: _ < work EXEC-(httpServer requestHandler)  writeHandler
;     3 args:  ^ worker. if it does DB_WRITE   ^ cog thread / handler for worker
;     1-workr  it has a cog thread to apply     activates when worker sends msg
;     2-cog    these writes to. (DB_READ)
;     3-conti  doesn't hit the cog but rather
;              uses its public state.
| return ()

main=(runCog newCogState reads newHttp)
;            ^ public state
;                        ^ DB_READ handler (allows parallel reads)
;                              ^ cog to run
