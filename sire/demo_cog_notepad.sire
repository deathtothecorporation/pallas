;;; Copyright 2024 OPFN
;;; Use of this source code is governed by a BSD-style license that can be
;;; found in the LICENSE file.
;;
#### demo_cog_notepad <- demo_cog_filepad

:| prelude
:| json
:| demo_cog_filepad
; :| datatype  [{#record} {#datatype} {#datacase}]

# typedef ContentType Bar

> HMap Str (ContentType, Pin Bar)
= startingFiles
| hmSingleton
* largeConfig

# record CogState
| COG_STATE
* note       : Nat
* files      : (HMap Str (ContentType, Pin Bar))
* fileBytes  : Nat
* servThread : ThreadId
* filesPort  : Nat

> ThreadId > CogState
= (newCogState filesPort servThread)
| COG_STATE
* b#{# Pallas Notepad\n\n- Any text entered here will be saved to Pallas.\n- Feel free to delete all of this intial content.\n\n**Enjoy!**}
* startingFiles
* 0
* servThread
* filesPort

(emptyFileServer req)=NONE

= (fileServer (PIN st) [method path query headers (PIN body)])
| trk [%fileServerRequest method path query headers body]
# switch method
* _ | NONE
* GET
  | **fmapMaybe | hmLookup (barNat path) (**getFiles st)
  & [type (PIN content)]
  @ head | [(b#{Content-Type}, type)]
  [200 b#gotcha head content]

= (modifyState vSt fun return)
: (PIN old) < readRef vSt
@ srv       | **getServThread old
@ pNew      | PIN (fun old)
: _         < writeRef vSt pNew
: _         < cancelFork srv (syscall (**HTTP_SERV | fileServer pNew))
| return ()

(bindMaybe mVal k)=(maybeCase mVal NONE k)

> Bar > Maybe (Tab Str Json)
= (jsonMap jsonBS)
@ res@[json leftover] (parseJson jsonBS)
| if (res || leftover) NONE
# datacase json
* JMAP|m | SOME m
* _      | NONE

= (asJsonStr m)
# datacase m
* JSTR|s | SOME s
* _      | NONE

= (asJsonNum m)
# datacase m
* JNUM|n | SOME n
* _      | NONE

= (parseNote jsonBS)
@ res@[json leftover] (parseJson jsonBS)
| trk [%parseNote jsonBS]
: string < bindMaybe (asJsonStr json)
| SOME string

= (parseNoteJson jsonBS)
: map < bindMaybe (jsonMap jsonBS)
: theNote < bindMaybe (tabLookup %newNote map)
| SOME (barNat theNote)

(msgToStr m)=(JSTR | natBar m)

= (buildJson st)
@ COG_STATE(..) st
| JMAP
## =note      | JVEC note
## =filesPort  | JNUM filesPort
## =files     | JVEC (map msgToStr (idx 0 (hmKeys files))) ; row-in-row for some reason
## =totalSize | JNUM fileBytes ; this is structured wrong ?

= corsHeaders [(b#{Access-Control-Allow-Origin}, b#{*}) (b#{Access-Control-Allow-Methods}, b#{PUT, GET, POST, DELETE, OPTIONS}) (b#{Access-Control-Allow-Headers}, b#{*}) (b#{Access-Control-Allow-Credentials}, b#{true})]

= (handleReq vSt request return)
@ [rid method path headers pBody@(PIN body)] request
# switch method
* GET
  # switch path
  * b#{/note}
    : (PIN st) < readRef vSt
    @ noteJson   | buildJson st
    @ noteJsonBS | printJson noteJson
    | trk [%json noteJsonBS]
    : _ < fork (syscall (**HTTP_ECHO rid 200 b#ok corsHeaders noteJsonBS))
    | return ()
  * _
    : _ < fork (syscall (**HTTP_ECHO rid 400 b#bad corsHeaders b#{}))
    | return ()
* POST
  # switch path
  * b#{/changed}
    : (PIN st) < readRef vSt
    @ noteState | getNote st
    @ noteNat | fromSome noteState | parseNoteJson body
    @ note | natBar noteNat
    : _ < modifyState vSt & st
                          | setNote | note
                          | st
    : _ < fork (syscall (**HTTP_ECHO rid 200 b#ok corsHeaders b#{}))
    | return ()
  * _
    : _ < fork (syscall (**HTTP_ECHO rid 400 b#bad corsHeaders b#{}))
    | return ()
* PUT
  : (PIN st) < readRef vSt
  @ barType | **fromSome b#{text/plain}
            | tabLookup b#{content-type}
            | tabFromPairs headers
  @ files (**getFiles st)
  @ files | hmInsert (barNat path) [barType pBody] files
  | trk [%newFiles files]
  @ newTotalSize | add (barLen body) | getFileBytes st
  | trk [%newSize newTotalSize]
  : _ < fork (syscall (**HTTP_ECHO rid 201 b#done corsHeaders b#{}))
  : _ < modifyState vSt & st
                        | setFileBytes newTotalSize
                        | setFiles files
                        | st
  | return ()
* OPTIONS
  : _ < fork (syscall (**HTTP_ECHO rid 200 b#ok corsHeaders b#{}))
  | return ()
* _
  : _ < fork (syscall (**HTTP_ECHO rid 400 b#bad corsHeaders b#{}))
  | return ()


= (runHttpServer vSt return)
: ??(rhs_heard req) < syscall HTTP_HEAR
: _                 < handleReq vSt req
| runHttpServer vSt return

fileCogChannel=66

= (parseNat bar)
@ wid (barLen bar)
@ hed (barIdx 0 bar)
| maybeGuardNot (isZero wid)
| maybeGuard    (isDigit hed)
@ acc (sub hed {0})
^ (_ acc 1)
? (go acc ix)
| if (gte ix wid) (SOME acc)
@ c (barGet bar ix)
| maybeGuard (isDigit c)
@ !acc (add (mul 10 acc) (sub c {0}))
| go acc inc-ix

= (spinNotes return)
| trk ["Notepad cog starting..."]
: filesCogID  < syscall | COG_SPIN (runCog spinFiles)
| trk ["Asking Files cog for port..."]
: ??(asker_told maybePort)
    < syscall (COG_ASK filesCogID fileCogChannel b#{what is your port?})
# datacase maybePort
* NONE
  | trk [%crashedNone]
  | return ()
* SOME-port
  | trk ["Got Files cog port!"]
  ; TODO: remove:
  ; | trk [%gotAskFromFiles port]
  : servThread  < fork (syscall (**HTTP_SERV emptyFileServer))
  : vSt         < newRef (PIN | newCogState port servThread)
  : httpThread1 < fork (runHttpServer vSt)
  : httpThread2 < fork (runHttpServer vSt)
  : notesPort        < syscall HTTP_PORT
  | trk ["Notepad cog UI ready " notesPort]
  | trk [(barCat [b#{Visit http://localhost:} (natBar | showNat notesPort) b#{/index.html}])]
  | return ()

main=(runCog spinNotes)
