; Copyright 2024 OPFN
; Use of this source code is governed by a BSD-style license that can be
; found in the LICENSE file.

; inline 'prelude' before 'demo_count_up'
#### demo_count_up <- prelude

; import 'prelude.sire'
:| prelude

;;; Count Up ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Bind a top-level function named countLoop that takes a 'count' parameter
; (and a 'k' parameter that we don't need to worry about now)
= (countLoop count k)
;
; Print out the current count value, using the bar | for function application.
| trk [{counter is at} count]
;
; Perform a system call for the current time and pass the result as an
; argument to an anonymous lambda.
| syscall TIME_WHEN
& now
; The following code is a continuation passed to the above syscall
;
; Wait until "now plus 1", discarding the result of this syscall to "_"
: _ < syscall (TIME_WAIT (inc now))
; The following code is a continuation passed to the above syscall
;
; Finally, recurr, increasing the count by one.
| countLoop (inc count) k
; End of countLoop function

; Bind a top-level "main" function that will run our program
= (main)
; Call "runCog" with our countLoop function. This will start a "process"
; that will be responsible for threads, system calls, and other overhead.
| runCog (countLoop 0)
