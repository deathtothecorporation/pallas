#### bst <- sire

;;;; This library implements an unbalanced binary search tree intended
;;;; to be used for symbol tables in Sire.
;;;;
;;;; Since this internal representation is exposed to macros via the
;;;; "scope" field of the Sire state, all implementations of Sire need
;;;; to implement this functionality in an identical way.  That's why
;;;; it's so important that this code be short and straightforward.
;;;;
;;;; Unbalanced binary search trees have degenerate performance with
;;;; certain usage patterns, however:
;;;;
;;;; -   Symbol tables generally do not exhibit the usage-patterns that
;;;;     lead to worst-case performance (for example, strictly defining
;;;;     short names before long names).
;;;;
;;;; -   The namespaces that Sire works with are mostly small, and
;;;;     never huge.
;;;;
;;;; -   Sire namespaces are also somewhat short-lived.  Even if one
;;;;     module hits a degenerate usage pattern, the next module will
;;;;     have a fresh namespaces, so the effect will not build up
;;;;     over time.
;;;;
;;;; -   The lack of any balancing means less work on insert, so there
;;;;     is some performance upside as well.
;;;;
;;;; Another design goal, is that this library have usable performance
;;;; for "new" runtime systems that still have bad performance and
;;;; few jets.  In this case, the lack of balancing logic is likely to
;;;; have an even more significant upside.


;;; Imports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:| sire


;;; Binary Search Trees ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= bstEmpty        | 0
= (**bstSing k v) | [k v 0 0]

= (bstList x@[_ _ l r]) | ifz-x NIL (listWeld (bstList l) x::(bstList r))
= (bstPairsList tree)   | listMap [k v _ _]&[k v] (bstList tree)
= (bstKeysList tree)    | listMap [k _ _ _]&k (bstList tree)
= (bstValsList tree)    | listMap [_ v _ _]&v (bstList tree)

;; {bstSave} takes a BST and produces a sorted array of key-value pairs.
;;
;; Completed Sire modules don't undergo further modification, so we only
;; care about storage overhead and lookup cost.  Compared with unbalanced
;; search trees, sorted arrays are faster to search and use less space.

(bstSave tree)=(listFromRow | bstPairsList tree)

= (bstSearch k tree)
| ifz tree NONE
@ [xk xv l r] tree
# switch (cmp k xk)
* 0 | bstSearch k l
* 1 | SOME xv
* 2 | bstSearch k r
* _ | NONE

;; This {merge} function always uses the root of the left tree as the
;; new root.  This has a bad effect on balance, but this is only needed
;; for deletion, which is not something that Sire does a lot of.

= (merge x@[xk xv xl xr] y@[yk yv yl yr])
| ifz x y
| ifz y x
| [yk yv (merge x yl) yr]

= (bstAlter k f x@[xk xv l r])
| ifz x | maybeCase (f NONE) 0 (bstSing k)
# switch (cmp k xk)
* 0 | [xk xv (bstAlter k f l) r]
* 1 | maybeCase (f SOME-xv) (merge l r) nv&[k nv l r]
* 2 | [xk xv l (bstAlter k f r)]

;; {bstLoad} takes a sorted array of pairs and uses that to directly
;; construct a balanced tree.

= (bstLoad pairs)
^ _ 0 (len pairs)
? (go off end)
@ wid  | sub end off
# switch wid
* 0 | bstEmpty
* 1 | uncurry bstSing (idx off pairs)
* _ @ mid   | add off (div wid 2)
    @ [k v] | idx mid pairs
    @ l     | go off mid
    @ r     | go inc-mid end
    | [k v l r]

;; This implementation of {bstFilterWithKey} has naive performance,
;; but it is used somewhat rarely.  The result is always balanced.

= (bstFilterWithKey f x)
| bstLoad | listToRow | listFilter (uncurry f) | bstPairsList x


;;; Convenience ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (bstIns k v t)        | bstAlter k const-(SOME v) t
= (bstPut t k v)        | bstAlter k const-(SOME v) t
= (bstDel k t)          | bstAlter k const-NONE t
= (bstHas k t)          | isApp (bstSearch k t)
= (bstIdx k v t)        | maybeCase (bstSearch k v t) 0 id
= bstIsEmpty            | isZero
= (bst xs)              | foldl     (t [k v]     & bstIns k v t) 0 xs
= (bstFromPairsList xs) | listFoldl (t [k v]     & bstIns k v t) 0 xs
= (bstUnion x y)        | listFoldl (t [k v _ _] & bstIns k v t) y bstList-x


;;; Tests ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Z=0
(O n)=[n n Z Z]
(N x l r)=[x x l r]

lef=(N 5 (N 4 O-3 Z) Z)
mid=(N 5 O-4 O-6)
ryt=(N 4 Z (N 5 Z O-6))

=?= O-5         | bstIns 5 5 bstEmpty
=?= (N 5 O-4 Z) | bstIns 4 4 | bstIns 5 5 bstEmpty
=?= lef         | bstIns 3 3 | bstIns 4 4 | bstIns 5 5 bstEmpty
=?= mid         | bstIns 6 6 | bstIns 4 4 | bstIns 5 5 bstEmpty
=?= ryt         | bstIns 6 6 | bstIns 5 5 | bstIns 4 4 bstEmpty

=?= NONE   | bstSearch 3 Z
=?= SOME-4 | bstSearch 3 (bstSing 3 4)
=?= NONE   | bstSearch 3 mid
=?= SOME-4 | bstSearch 4 mid
=?= SOME-5 | bstSearch 5 mid
=?= SOME-6 | bstSearch 6 mid
=?= NONE   | bstSearch 7 mid

=?= mid         | bstDel 3 mid
=?= (N 5 Z O-6) | bstDel 4 mid
=?= (N 6 O-4 Z) | bstDel 5 mid
=?= (N 5 O-4 Z) | bstDel 6 mid
=?= mid         | bstDel 7 mid

big=(foldl (t n)&(bstIns n n t) Z [4 2 3 1 6 5 7])
lef=(foldl (t n)&(bstIns n n t) Z [4 2 3 1 6])
ryt=(foldl (t n)&(bstIns n n t) Z [4 1 6 5 7])

=?= SOME-7 | bstSearch 7 big
=?= SOME-7 | bstSearch 7 ryt
=?= NONE   | bstSearch 7 lef

=?= (bstDel 4 ryt) | (N 6 (N 5 O-1 Z) O-7)
=?= (bstDel 4 lef) | (N 6 (N 2 (N 1 Z Z) (N 3 Z Z)) Z)
=?= (bstDel 4 big) | (N 6 (N 5 (N 2 O-1 O-3) Z) O-7)

(ex n)=(| bstLoad | listToRow | listDrop 1 | listGen inc-n i&[i i])

=?= (ex 0) | Z
=?= (ex 1) | O-1
=?= (ex 2) | N 2 (N 1 Z Z) Z
=?= (ex 3) | N 2 (N 1 Z Z) (N 3 Z Z)
=?= (ex 4) | N 3 (N 2 (N 1 Z Z) Z) (N 4 Z Z)
=?= (ex 5) | N 3 (N 2 (N 1 Z Z) Z) (N 5 (N 4 Z Z) Z)
=?= (ex 6) | N 4 (N 2 (N 1 Z Z) (N 3 Z Z)) (N 6 (N 5 Z Z) Z)
=?= (ex 7) | (N 4 (N 2 (N 1 Z Z) (N 3 Z Z)) (N 6 (N 5 Z Z) (N 7 Z Z)))


;;; Exports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

^-^ bst
^-^ bstAlter
^-^ bstDel
^-^ bstEmpty
^-^ bstFilterWithKey
^-^ bstFromPairsList
^-^ bstHas
^-^ bstIdx
^-^ bstIns
^-^ bstIsEmpty
^-^ bstKeysList
^-^ bstList
^-^ bstPairsList
^-^ bstPut
^-^ bstSave
^-^ bstSearch
^-^ bstSing
^-^ bstUnion
^-^ bstValsList
