(HEIR a b c)=(R4:0 a b c)
(if a b c)=(2 c ((d e & d) b) a)
(aeqZero a)=(2:1:(b&0) a)
(exec a b c)=(2 b (exec a a-b) c)
(dec a)=(2:0:(b&b) a)
(sub a b)=(exec:dec a b)
(lte a b)=(aeqZero sub-a-b)
(lth a b)=(lte 3-a b)

= (arity a)
. a
| 1:(b c d & c) ((b c d & dec b-c) arity)
| 2:3:(2 4 (2 3 b&1))

(isApp a)=(1:(b c d & 0):(b c & 1):(b&0) a)
(appHead a)=(1:(b c d & 0):(b c & b):(b&0) a)
(head a)=(if isApp-a (head appHead-a) a)
(len a)=(dec (arity head-a))
(LEFT a)=(0 a)
(gte a b)=(lte b a)
(ifNot a b c)=(2 b ((d e & d) c) a)
(car a)=(1:(b c d & 0-b-c):(b c & b):(b&0) a)
(cdr a)=(1:(b c d & d):(b c & c):(b&0) a)
(toBool a)=(2:0:(b&1) a)
(and a b)=(if a toBool-b 0)
(aeq a b)=(and lte-b-a lte-a-b)
(appTail a)=(1:(b c d & 0):(b c & c):(b&0) a)

= (idx a b)
@ c
   . a b
   ? (loop d e)
   | ifNot isApp-e 0:0
   @ f (loop d appHead-e)
   | if car-f f
   | (g @ cdr-f)(if aeq-d-g (1 appTail-e) (0 3-g))
| if appHead-c appTail-c 0

(switch a b c)=(if (gte a len-c) b idx-a-c)
(toNat a)=(2:0:3 a)
(add a b)=(exec:3 toNat-a b)
(mul a b)=(exec add-a 0 b)
(bex a)=(exec:(mul-2):1 a)
(lsh a b)=(mul bex-b a)
(die a)=(die a)
(until a b c d)=(if a-d c (b until-a-b c d))
(gth a b)=(lth b a)

= (div a b)
| ifNot b (die 'divide by zero')
| until gth-b ((c d e f & d 3-e sub-f-c) b) 0 a

(mod a b)=(sub a (mul b div-a-b))
(roundUp a b)=(ifNot b a (ifNot mod-a-b a (sub add-a-b mod-a-b)))
(rsh a b)=(div a bex-b)
(bitWidth a)=(until:aeqZero:(b c d & b 3-c rsh-d-1):0 a)
(blockWeld a b c)=(add b (lsh c (roundUp bitWidth-b a)))
(cordWeld a b)=(blockWeld:8 a b)
(not a)=(2:1:(b&0) a)
(isFun a)=(1:(b c d & 1):(b c & 0):(b&0) a)
(funArgs a)=(1:(b c d & c):(b c & 0):(b&0) a)
(funName a)=(1:(b c d & b):(b c & 0):(b&0) a)
(funBody a)=(1:(b c d & d):(b c & 0):(b&0) a)
(isNat a)=(1:(b c d & 0):(b c & 0):(b&1) a)

= (eql a b)
| if isFun-a
   | and isFun-b
   | and (aeq funArgs-a funArgs-b)
   | and (aeq funName-a funName-b)
   | eql funBody-a funBody-b
| if isApp-a
   | and isApp-b
   | and (eql appHead-a appHead-b)
   | eql appTail-a appTail-b
| and isNat-b aeq-a-b

(get a b)=(idx b a)

= (foldr a b c)
| ifNot len-c b
. a b c len-c 0
? (loop d e f g h)
(if eql-h-g e (d get-f-h (loop d e f g 3-h)))

(or a b)=(if a 1 toBool-b)
(rowOr a)=(foldr:or:0 a)
(mkRow a)=(0:0 3-a 0)

= (gen a b)
. b a 0 mkRow-a
? (loop c d e f)
(ifNot d f (loop c dec-d 3-e (f c-e)))

(map a b)=(gen len-b ((c d e & c get-d-e) a b))
(any a b)=(rowOr map-a-b)
(has a b)=(any eql-a b)
(tabKeys a)=(funBody head-a)
(tabHas a b)=(has a tabKeys-b)
(showSymbol a)=a
(SOME a)=(0 a)

= (find a b)
. a b len-b 0
? (loop c d e f)
| if eql-e-f 0
| if (eql c get-d-f) SOME-f (loop c d e 3-f)

= (tabIdx a b)
@ c (find a (funBody head-b))
| if isNat-c 0 (idx cdr-c b)

(tabGet a b)=(tabIdx b a)
(drop a b)=(gen (sub len-b a) ((c d e & get d add-e-c) a b))

= ('#' a b c d)
@ e (HEIR:35 c d)
| if
   (lth len-c 1)
   (LEFT (R2 e '# Macros needs at least on kid'))
@ f
   | LEFT
   | R2 e
      '''First parameter to # must be a bare-word
| switch (idx:0 (idx:0 c)) 0
. f f f
| R5 f
@ g (cordWeld:35 (idx:1 (idx:0 c)))
| if (not tabHas-g-a)
   | LEFT
   | R2 e (cordWeld:'Undefined Symbol: ' showSymbol-g)
| tabGet a g a b (drop:1 c) d

= (weld a b)
@ c len-a
| gen (add c len-b)
| (d e f g & if lth-g-f get-d-g (get e sub-g-f)) a b
| c

(mergeHeir a b)=(if (eql:0 b) a (weld a R1-b))
(neq a b)=(not eql-a-b)
(NODE a b)=(R3:0 a b)
(mkHeir a b c)=(if (eql:0 c) NODE-a-b HEIR-a-b-c)
(cordConcat a)=(foldr:cordWeld:[] a)
(seq a b)=(2 b ((c d & c) b) a)

= (listFoldl a b c)
| if isNat-c b
| (d @ a b (idx:0 c))(seq d (listFoldl a d (idx:1 c)))

(apply a b)=(a b)
(listFoldr a b c)=(if isNat-c b (a (idx:0 c) (listFoldr a b (idx:1 c))))
(listLen a)=(listFoldr:(b c & 3-c):0 a)
(listToRow a)=(listFoldl:apply (mkRow listLen-a) a)
(CONS a b)=(R2 a b)

= (listDigits a)
| ifNot a (CONS:48 0)
. a 0
? (loop b c)
| seq c
| ifNot b c (loop div-b-10 (R2 (add mod-b-10 48) c))

(digits a)=(listToRow listDigits-a)
(showNat a)=(cordConcat digits-a)
(supply a b)=(b a)
(listToRowReversed a)=(listFoldr:supply (mkRow listLen-a) a)
(listFromRow a)=(foldr:CONS:0 a)

= (eitherRowSequence a)
|  :  ? (loop b c)
      | if isNat-c (1 listToRowReversed-b)
      | if
         (car (idx:0 c))
         (loop (CONS (cdr (idx:0 c)) b) (idx:1 c))
      | 0 (cdr (idx:0 c))
   : 0
| listFromRow-a

(min a b)=(if lte-a-b a b)

= (zipWith a b c)
| gen (min len-b len-c)
| (d e f g & d idx-g-e idx-g-f) a b c

= (foldl a b c)
. a c len-c b 0
? (loop d e f g h)
| if gte-h-f g
| (i @ d g get-e-h)(seq i (loop d e f i 3-h))

(rowApply a b)=(foldl:apply a b)

= (gensymMacro a b c d e f g)
@ h mergeHeir-f-g
| if (neq len-b len-h)
   | LEFT
   | R2 mkHeir-a-f-g
   | cordConcat
   | R3:'Expecting ' (showNat len-b)
      ''' parameters
@ i (eitherRowSequence (zipWith:apply b h))
| if car-i (rowApply c-e cdr-i) i

(eitherRowTraverse a b)=(eitherRowSequence map-a-b)
(force a)=(0!0!0 2-a)
(deepseq a b)=(seq force-a b)
(trk a b)=(deepseq a b)
(trkVal a b)=(trk R2-a-b b)

= (perbit a b c)
. c a b 0 0
? (loop d e f g h)
| if (and aeqZero-e aeqZero-f) h
| loop d div-e-2 div-f-2 3-g
| add h (lsh (d mod-e-2 mod-f-2) g)

(dis a b)=(perbit a b and)

= (explode a)
@ b (div (roundUp bitWidth-a 8) 8)
. b 0 a mkRow-b
? (loop c d e f)
(if eql-d-c f (loop c 3-d rsh-e-8 (f (dis:255 e))))

(isDigit a)=(and gte-a-48 lte-a-57)
(rowAnd a)=(foldr:and:1 a)
(all a b)=(rowAnd map-a-b)
(isUpper a)=(and gte-a-65 lte-a-90)
(isLower a)=(and gte-a-97 lte-a-122)
(isAlpha a)=(or isUpper-a isLower-a)
(okaySymbolChar a)=(or (eql:95 a) (or isAlpha-a isDigit-a))

= (okaySymbol a)
| if (eql:0 a) 0
@ b explode-a
| and (not (isDigit (idx:0 b))) (all:okaySymbolChar b)

(RIGHT a)=(1 a)

= (readSymbol_1$readSymbol a)
| trkVal (R2:(%readSymbol) a)
@ b (LEFT (R2 a '`readSymbol` expected a NAME node'))
| switch (idx:0 a) 0
. b b b
| R5 b
@ c (idx:1 a)
. RIGHT-c
| ifNot okaySymbol-c
| LEFT (R2 a 'Invalid Character in Symbol')

= (readRowOfNames_1$readRowOfNames a b)
@ c
   | LEFT
   | R2 b
   | cordWeld a
   |
      ''' pattern must be a symbol (x) or a row of: (x,y,z)
| switch (idx:0 b) 0
. c c c
| R5
   | if (neq (idx:1 b) 44) c
   | if
      (neq (idx:3 b) 0)
      (LEFT (R2 b 'name-sequence cannot have an heir'))
   | eitherRowTraverse:readSymbol_1 (idx:2 b)
| (d @ readSymbol_1-b)(if car-d (idx:0 cdr-d) d)

(WORD a)=(R2:1 a)
(gensymE a)=(WORD (cordWeld:(%_g) showNat-a))
(letE a b c)=(HEIR:64 R2-a-b c)
(appE a)=(NODE:124 a)
(VRAW a)=(R2:4 a)
(cnsE a)=(VRAW a)
(natE a)=(WORD showNat-a)

= (listZipWith a b c)
| if isNat-b 0
| if isNat-c 0
| R2 (a (idx:0 b) (idx:0 c))
| listZipWith a (idx:1 b) (idx:1 c)

(listZip a b)=(listZipWith:R2 a b)
(listEnumFrom a)=(R2 a (listEnumFrom 3-a))

= ('#openRow' a b c d)
. a b c d
: gensymMacro
:
   '''#openRow
: [(readRowOfNames_1 'In *~ names list,') RIGHT RIGHT]
:  & (e f g h)
   @ i gensymE-e
   | RIGHT
   | R2:1
   | letE i g
   |
            ? (bindSlots f g h)
            | if isNat-h f
            @ i (idx:0 h)
            | letE
               (WORD (idx:1 i))
               (appE (R3 cnsE-idx (natE (idx:0 i)) g))
            | bindSlots f g (idx:1 h)
         h
      i
   | listZip listEnumFrom-0 listFromRow-f

(I a)=a
(K a b)=a
(S a b c)=(a c b-c)

= ('`' a b c d)
@ e mergeHeir-c-d
| if (neq:1 len-e)
   '''Expected 1 Parameter
| RIGHT (R2:0 (cnsE (idx:0 e)))

(vecE a)=(NODE:44 a)

= ('~' a b c d)
@ e
   | LEFT
   | R2 (HEIR:126 c d)
   '''~ expects to be wrapped around a tuple literal: `~[3 4 5]`
| if (or (neq:0 d) (neq:1 len-c)) e
| switch (idx:0 (idx:0 c)) 0
. e e e e
| R5
| if (neq (idx:1 (idx:0 c)) 44) e
| RIGHT
| R2:0
| foldr:(f g & vecE R2-f-g) natE-0
| mergeHeir (idx:2 (idx:0 c)) (idx:3 (idx:0 c))

= (readSymbol_2$readSymbol a)
@ b (LEFT (R2 a '`readSymbol` expected a NAME node'))
| switch (idx:0 a) 0
. b b b
| R5 b
@ c (idx:1 a)
. RIGHT-c
| ifNot okaySymbol-c
| LEFT (R2 a 'Invalid Character in Symbol')

= (readRowOfNames_2$readRowOfNames a b)
@ c
   | LEFT
   | R2 b
   | cordWeld a
   |
      ''' pattern must be a symbol (x) or a row of: (x,y,z)
| switch (idx:0 b) 0
. c c c
| R5
   | if (neq (idx:1 b) 44) c
   | if
      (neq (idx:3 b) 0)
      (LEFT (R2 b 'name-sequence cannot have an heir'))
   | eitherRowTraverse:readSymbol_2 (idx:2 b)
| (d @ readSymbol_2-b)(if car-d (idx:0 cdr-d) d)

= ('#*' a b c d)
. a b c d
: gensymMacro
:
   '''#*
: [(readRowOfNames_2 'In *~ names list,') RIGHT RIGHT]
:  & (e f g h)
   @ i gensymE-e
   | RIGHT
   | R2:1
   | letE i g
   |
            ? (bindSlots f g h)
            | if isNat-h f
            @ i (idx:0 h)
            | letE
               (WORD (idx:1 i))
               (appE (R3 cnsE-idx (natE (idx:0 i)) g))
            | bindSlots f g (idx:1 h)
         h
      i
   | listZip listEnumFrom-0 listFromRow-f

(w8 a)=(mod a 256)

= (simpleMacro a b c d e f g)
@ h mergeHeir-f-g
| if (neq len-b len-h)
   | LEFT
   | R2 mkHeir-a-f-g
   | cordConcat
   | R3:'Expecting ' (showNat len-b)
      ''' parameters
@ i (eitherRowSequence (zipWith:apply b h))
. i
| if car-i
@ j (rowApply c cdr-i)
| if car-j (RIGHT (R2:0 cdr-j)) j

= ('/=' a b c d)
. a b c d
: simpleMacro
:
   '''/=
: [RIGHT RIGHT]
:  & (e f)
   (RIGHT (appE (R2 cnsE-not (NODE:'==' R2-e-f))))

= ('==' a b c d)
@ e mergeHeir-c-d
| RIGHT
| switch len-e
   | R2:1
   @ f gensymE-b
   | letE f (idx:0 e)
   |     ? (loop g h)
         | if isNat-h (die %impossible)
         @ i (idx:0 h)
         @ j (idx:1 h)
         | if isNat-j (appE (R3 cnsE-eql g i))
         | appE
            (R3 cnsE-and (appE (R3 cnsE-eql g i)) loop-g-j)
      f
   | listFromRow (drop:1 e)
| R3
   (R2:0 natE-1)
   (R2:0 (appE (R3 cnsE-seq (idx:0 e) natE-1)))
| R2:0 (appE (R3 cnsE-eql (idx:0 e) (idx:1 e)))

= ('#@' a b c d)
@ e mergeHeir-c-d
| if (neq:3 len-e)
   '''Expected 3 parameters
@ f (idx:0 e)
| RIGHT
| R2:0
| NODE:64
| R3 f (idx:1 e)
| appE
| R4 cnsE-if (appE (R2:[4 isNat] f)) f (idx:2 e)

= (barLit a b c d e f)
@ g (HEIR:35 (weld WORD-a e) f)
@ h (LEFT (R2 g 'Expcted two kids and no heir'))
@ i (LEFT (R2 g 'Bar literal expects a text parameter'))
| if (neq:0 f) h
| if (neq:1 len-e) h
| switch (idx:0 (idx:0 e)) 0
. i
| R5
   i
   (RIGHT (R2:0 (cnsE (b (idx:1 (idx:0 e))))))
   (RIGHT (R2:0 (cnsE (b (idx:1 (idx:0 e))))))
| RIGHT (R2:0 (cnsE (b (idx:1 (idx:0 e)))))

= (byteWidth a)
|  : (loop b c ? seq b (ifNot c b (loop 3-b rsh-c-8)))
   : 0
| a

(barEnc a b)=(add b (bex (mul:8 (add a byteWidth-b))))
(mkBar a b)=(0!1!1 barEnc-a-b)
(natBar a)=(mkBar:0 a)
(hexCharToNat a)=(if lte-a-57 sub-a-48 (add:10 (sub min-a-102 97)))
(concat a)=(foldr:weld:[] a)
(even_1$even a)=(not mod-a-2)

= (barFromHex a)
@ b (map:hexCharToNat explode-a)
. 1
|  :  ? (loop c d e)
      | seq c
      | if isNat-d (0!1!1 c)
      | if (isNat (idx:1 d)) (die %impossible)
      | loop
            | add c
            | add (mul e (idx:0 (idx:1 d)))
            | mul e (mul:16 (idx:0 d))
         (idx:1 (idx:1 d))
      | mul:256 e
   : 0
| listFromRow
| concat (R3 (if (even_1 len-b) [] [0]) b [0 1])

(appify a)=(if (eql:1 len-a) (idx:0 a) (NODE:124 a))

= (unrollSlip2 a b c)
. a b 0 c
? (loop d e f g)
@ h loop-d-e
@ i (j @ e-g)(if car-j (h (CONS cdr-j f) 0) cdr-j)
| if (eql:0 g) listToRowReversed-f
| switch (idx:0 g) 0
. i i i i
| R5
| if (neq d (idx:1 g)) i
| h (CONS (idx:2 g) f) (idx:3 g)

= ('~~' a b c d)
| RIGHT
| R2:0
| foldr:(e f & vecE (R2 appify-e f)) natE-0
| unrollSlip2:'~~':(e & RIGHT R1-e) (HEIR:'~~' c d)

(i32 a)=(mod a 4294967296)
(w32 a)=(mod a 4294967296)
(i48 a)=(mod a 281474976710656)
(w48 a)=(mod a 281474976710656)
(match a b c)=(switch (idx:0 a) b c)

= (odd a)
. a
: (b c & b (R2:1 c))
:  ? (even_odd b)
   | match b 0
   | R2 (c @ idx:1 b)(ifNot c 1 (even_odd (R2:1 dec-c)))
   | (c @ idx:1 b)(ifNot c 0 (even_odd (R2:0 dec-c)))

(dropHighBit a)=(sub a (bex (dec bitWidth-a)))
(xor a b)=(if a not-b toBool-b)
(mix a b)=(perbit a b xor)
(takeBits a b)=(mod b bex-a)

= (mat a)
| ifNot a [1 1]
@ b bitWidth-a
@ c bitWidth-b
| R2 (add b (dec add-c-c))
| add bex-c
| lsh (dropHighBit (mix (takeBits dec-c b) (lsh a dec-c)))
| 3-c

= (listLookup a b)
| if isNat-b 0
| if (eql (idx:0 (idx:0 b)) a) (SOME (idx:1 (idx:0 b)))
| listLookup a (idx:1 b)

= (jam a b)
@ c
   ? (loop e)
   @ f ((j k l m & j (R4:0 k l m)) loop)
   @ g ((j k l m n & j (R5:2 k l m n)) loop)
   @ h ((j k l m & j (R4:3 k l m)) loop)
   | match e 0
   | R4
            @ i (mat (idx:3 e))
            . (idx:2 e)
            | R4 (idx:1 e) (add:2 (idx:0 i))
            | mix:3 (lsh (idx:1 i) 2)
         @ i (mat (idx:3 e))
         . (idx:2 e)
         | R4 (idx:1 e) (add:2 (idx:0 i))
         | mix:1 (lsh (idx:1 i) 2)
      @ i (loop (R4:3 (3 (idx:1 e)) (idx:2 e) (idx:3 e)))
      @ j (idx:1 i)
      @ k (loop (R4:3 (3 (idx:0 i)) (idx:3 i) (idx:4 e)))
      . (idx:3 k)
      | R4 (idx:0 k) (add:1 (add j (idx:1 k)))
      | mul:2 (add (idx:2 i) (lsh (idx:2 k) j))
   @ i (idx:1 e)
   @ j (idx:2 e)
   @ k (idx:3 e)
   @ l listLookup-k-j
   | if isNat-l
      @ m (CONS R2-k-i j)
      | if isNat-k (loop (R4:0 i m k))
      | if isApp-k (loop (R5:2 i m car-k cdr-k))
      | loop
         (R5:2 i m (0 funName-k funArgs-k) funBody-k)
   @ m cdr-l
   | if
      (and isNat-k (lte bitWidth-k bitWidth-m))
      (loop (R4:0 i j k))
   | loop (R4:1 i j m)
@ d
   | c
   | R4:3
      len-a
      (listZip listFromRow-a listEnumFrom-0)
      b
| add (idx:2 d) (bex (idx:1 d))

(sum a)=(foldr:add:0 a)
(con a b)=(perbit a b or)
(rap a b)=(foldl blockWeld-a 0 b)

= (zip a b)
| gen (min len-a len-b)
| (c d e & R2 idx-e-c idx-e-d) a b

= (isPin a)
| and isFun-a
. funArgs-a funBody-a
? (go b c)
@ d car-c
| ifNot b (eql:2 d)
| and (eql b cdr-c)
| and (eql:0 car-d) (go dec-b cdr-d)

(listOr a)=(listFoldr:or:0 a)

= (listMap a b)
| if isNat-b 0
| R2 (a (idx:0 b)) (listMap a (idx:1 b))

(listAny a b)=(listOr listMap-a-b)
(listHas a b)=(listAny eql-a b)

= (pinItem a)
. funBody-a
? (go b)
| if isNat-b 0
| (c @ car-b)(if isNat-c cdr-b (go cdr-c))

= (refs a)
| listToRowReversed
|  :  ? (go b c)
      | if isPin-c (if listHas-c-b b CONS-c-b)
      | if isApp-c (go (go b car-c) cdr-c)
      | if isFun-c (go b funBody-c) b
   : 0
| if isPin-a pinItem-a a

(take a b)=(gen (min a len-b) get-b)

= (wordToBytes a)
. a mkRow-4
:  ? (go b c d)
   (if eql-b-4 d (go 3-b rsh-c-8 (d (dis:255 c))))
: 0

(wordsToBytes a)=(concat (map:wordToBytes a))

= (b3Permute a)
| gen:16
. a
& (b c)
| get b
| get:[2 6 3 10 7 0 4 13 1 11 12 5 9 14 15 8] c

= (update a b c)
| gen len-c
| (d e f g & if eql-g-d e idx-g-f) a b c

(put a b c)=(update b c a)
(xor32 a b)=(mix w32-a w32-b)
(add32 a b)=(w32 (add w32-a w32-b))
(or32 a b)=(con w32-a w32-b)
(and32 a b)=(dis w32-a w32-b)
(rsh32 a b)=(and32 (rsh w32-a w32-b) 4294967295)
(lsh32 a b)=(and32 (lsh w32-a w32-b) 4294967295)
(lte32 a b)=(lte w32-a w32-b)

= (sub32 a b)
| if lte32-b-a (sub w32-a w32-b)
| sub (add:4294967296 a) b

(ror32 a b)=(or32 rsh32-a-b (lsh32 a (sub32:32 b)))

= (b3G a b c d e f g)
@ h (put a b (add32 (add32 get-a-b get-a-c) f))
@ i (put h e (ror32 (xor32 get-h-e get-h-b) 16))
@ j (put i d (add32 get-i-d get-i-e))
@ k (put j c (ror32 (xor32 get-j-c get-j-d) 12))
@ l (put k b (add32 (add32 get-k-b get-k-c) g))
@ m (put l e (ror32 (xor32 get-l-e get-l-b) 8))
@ n (put m d (add32 get-m-d get-m-e))
| put n c (ror32 (xor32 get-n-c get-n-d) 7)

= (b3Round a b)
. 3 4 9 14 get-b-14 get-b-15
| b3G
. 2 7 8 13 get-b-12 get-b-13
| b3G
. 1 6 11 12 get-b-10 get-b-11
| b3G
. 0 5 10 15 get-b-8 get-b-9
| b3G
. 3 7 11 15 get-b-6 get-b-7
| b3G
. 2 6 10 14 get-b-4 get-b-5
| b3G
| b3G (b3G a 0 4 8 12 get-b-0 get-b-1) 1 5 9 13 get-b-2
| get-b-3

(chop32 a)=(and32 a 4294967295)

= (b3Compress a)
@ b (idx:0 a)
@ c (idx:2 a)
@ d (b3Permute (idx:1 a))
@ e b3Permute-d
@ f b3Permute-e
@ g b3Permute-f
@ h b3Permute-g
|
         ? (loop i j k)
         | if eql-j-8 k
         @ l (put k j (xor32 (get k add-j-8) get-k-j))
         | loop i 3-j
         | put
            l
            add-j-8
            (xor32 (get l add-j-8) get-i-j)
      b
   0
| b3Round
   . h
   | b3Round
   . g
   | b3Round
   . f
   | b3Round
   . e
   | b3Round
   . d
   | b3Round
   . (idx:1 a)
   | b3Round
   . (idx:3 a) (idx:4 a)
   | R16 get-b-0 get-b-1 get-b-2 get-b-3 get-b-4 get-b-5 get-b-6 get-b-7
                  . 0
                  : get
                  :  ,, 1779033703
                     ,, 3144134277
                     ,, 1013904242
                     ,, 2773480762
                     ,, 1359893119
                     ,, 2600822924
                     ,, 528734635
                     ,, 1541459225
               . 1
               : get
               :  ,, 1779033703
                  ,, 3144134277
                  ,, 1013904242
                  ,, 2773480762
                  ,, 1359893119
                  ,, 2600822924
                  ,, 528734635
                  ,, 1541459225
            . 2
            : get
            :  ,, 1779033703
               ,, 3144134277
               ,, 1013904242
               ,, 2773480762
               ,, 1359893119
               ,, 2600822924
               ,, 528734635
               ,, 1541459225
         . 3
         : get
         :  ,, 1779033703
            ,, 3144134277
            ,, 1013904242
            ,, 2773480762
            ,, 1359893119
            ,, 2600822924
            ,, 528734635
            ,, 1541459225
      chop32-c
   | chop32 rsh-c-32
| b3Permute-h

(b3OutputGetInputChainingValue a)=(get a 0)
(b3OutputGetBlockWords a)=(get a 1)
(b3OutputGetBlockLen a)=(get a 3)
(b3OutputGetFlags a)=(get a 4)

= (b3OutputRootOutputBytes a b)
@ c (mul:2 32)
@ d (div roundUp-b-c c)
| concat
. a c d 0 b mkRow-d
? (loop e f g h i j)
| if eql-h-g j
@ k min-f-i
| loop e f g 3-h sub-i-k
| j
| take k
| wordsToBytes
| b3Compress
| R5
   b3OutputGetInputChainingValue-e
   b3OutputGetBlockWords-e
   h
   b3OutputGetBlockLen-e
| or32 b3OutputGetFlags-e 8

(b3OutputNew a b c d e)=(R5 a b c d e)

= (b3ParentOutput a b c d)
| b3OutputNew c (weld (take:8 a) (take:8 b)) 0 64
| or32:4 d

= (splice a b c)
|
            ? (loop d e f g)
            (if gte-f-e g (loop d e 3-f (g get-d-f)))
         a
      c
   b
| mkRow sub-c-b

(first8words a)=(splice a 0 8)
(b3OutputChainingValue a)=(first8words b3Compress-a)
(b3HasherGetKeyWords a)=(get a 1)
(b3HasherGetFlags a)=(get a 3)
(b3ChunkstGetChainingVal a)=(get a 0)
(u8weld a b)=(add a lsh-b-8)

= (u32weld a)
| if (not (aeq len-a 4)) (die 'u32weld requires 4 bytes')
| u8weld get-a-0
| u8weld get-a-1 (u8weld get-a-2 get-a-3)

= (bytesToWords a)
| if
   (mod len-a 4)
   (die 'byte-row length not a multiple of 4')
@ b (div len-a 4)
. a b 0 0 mkRow-b
? (loop c d e f g)
| if eql-f-d g
@ h add-e-4
| loop c d h 3-f (g (u32weld splice-c-e-h))

(b3ChunkstGetBlock a)=(get a 2)
(b3ChunkstGetChunkCounter a)=(get a 1)
(b3ChunkstGetBlockLen a)=(get a 3)
(b3ChunkstGetFlags a)=(get a 5)
(b3ChunkstGetBlocksCompressed a)=(get a 4)
(b3ChunkstStartFlag a)=(if (eql b3ChunkstGetBlocksCompressed-a 0) 1 0)

= (b3ChunkstOutput a)
| b3OutputNew
   b3ChunkstGetChainingVal-a
   (bytesToWords b3ChunkstGetBlock-a)
   b3ChunkstGetChunkCounter-a
   b3ChunkstGetBlockLen-a
| or32 (or32 b3ChunkstGetFlags-a b3ChunkstStartFlag-a)
| 2

(b3HasherGetChunkst a)=(get a 0)
(b3HasherGetCvStack a)=(get a 2)

= (b3Finalize a b)
|
            ? (go c d e f)
            | if isNat-f b3OutputRootOutputBytes-e-d
            . (idx:1 f)
            | go c d
            | b3ParentOutput
               (idx:0 f)
               b3OutputChainingValue-e
               b3HasherGetKeyWords-c
            | b3HasherGetFlags-c
         a
      b
   (b3ChunkstOutput b3HasherGetChunkst-a)
| b3HasherGetCvStack-a

= (b3ChunkstLen a)
| add b3ChunkstGetBlockLen-a
| mul:64 b3ChunkstGetBlocksCompressed-a

(b3HasherPutChunkst a b)=(put a 0 b)
(b3ChunkstPutChainingVal a)=(put a 0)
(b3ChunkstPutBlockLen a)=(put a 3)
(b3ChunkstPutBlock a)=(put a 2)
(b3ChunkstPutBlocksCompressed a)=(put a 4)
(replicate a b)=(gen b ((c d & c) a))

= (b3ChunkstUpdate a b)
| if (eql len-b 0) a
@ c
   | if (neq:64 b3ChunkstGetBlockLen-a) a
   @ d
      | b3ChunkstPutChainingVal a
      | first8words
      | b3Compress
      | R5
         b3ChunkstGetChainingVal-a
         (bytesToWords b3ChunkstGetBlock-a)
         b3ChunkstGetChunkCounter-a
         64
      | or32 b3ChunkstGetFlags-a b3ChunkstStartFlag-a
   . 0
   | b3ChunkstPutBlockLen
   | b3ChunkstPutBlock
      | b3ChunkstPutBlocksCompressed d
      | 3 b3ChunkstGetBlocksCompressed-d
   | replicate:0 64
@ d (min (sub:64 b3ChunkstGetBlockLen-c) len-b)
@ e
   | b3ChunkstPutBlock c
   | weld take-d-b (drop d b3ChunkstGetBlock-c)
. drop-d-b
| b3ChunkstUpdate
| b3ChunkstPutBlockLen e
| add b3ChunkstGetBlockLen-e d

(b3HasherPutCvStack a b)=(put a 2 b)

= (b3HasherPopStack a)
@ b b3HasherGetCvStack-a
| if isNat-b (die 'Trying to pop empty stack')
| R2 (idx:0 b) (b3HasherPutCvStack a (idx:1 b))

(b3ParentCv a b c d)=(b3OutputChainingValue b3ParentOutput-a-b-c-d)
(b3HasherPushStack a b)=(b3HasherPutCvStack a (R2 b b3HasherGetCvStack-a))

= (b3HasherAddChunkChainingValue a b c)
. a b c
? (go d e f)
| ifNot and32-f-1
   @ g b3HasherPopStack-d
   @ h (idx:1 g)
   . rsh-f-1
   | go h
   | b3ParentCv (idx:0 g) e b3HasherGetKeyWords-h
   | b3HasherGetFlags-h
| b3HasherPushStack-d-e

(b3ChunkstNew a b c)=(R6 a b (replicate:0 64) 0 0 c)

= (b3HasherUpdate a b)
@ c
   |  & (f g h)
      @ i
         | min
            (sub:1024 (b3ChunkstLen b3HasherGetChunkst-g))
         | len-h
      . drop-i-h
      | f
      | b3HasherPutChunkst g
      | b3ChunkstUpdate b3HasherGetChunkst-g take-i-h
   | b3HasherUpdate
| ifNot len-b a
| if (neq:1024 (b3ChunkstLen b3HasherGetChunkst-a)) c-a-b
@ d (3 (b3ChunkstGetChunkCounter b3HasherGetChunkst-a))
@ e
   . d
   | b3HasherAddChunkChainingValue a
   | b3OutputChainingValue
   | b3ChunkstOutput b3HasherGetChunkst-a
. b
| c
| b3HasherPutChunkst e
| b3ChunkstNew b3HasherGetKeyWords-e d
| b3HasherGetFlags-e

= (blake3 a)
. 32
| b3Finalize
. a
: b3HasherUpdate
:  ,, ,, ,, 1779033703
         ,, 3144134277
         ,, 1013904242
         ,, 2773480762
         ,, 1359893119
         ,, 2600822924
         ,, 528734635
         ,, 1541459225
      ,, 0
      ,, ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
         ,, 0
      ,, 0
      ,, 0
      ,, 0
   ,, ,, 1779033703
      ,, 3144134277
      ,, 1013904242
      ,, 2773480762
      ,, 1359893119
      ,, 2600822924
      ,, 528734635
      ,, 1541459225
   ,, 0
   ,, 0

= (jar a)
@ b refs-a
@ c (explode jam-b-a)
. b c
| R3
| blake3
| concat
. c
| R3 (concat (map ((d e & idx:0 (d pinItem-e)) jar) b))
| replicate:0 32

(nor a b)=(not or-a-b)
(max a b)=(if gth-a-b a b)
(PAGE a)=(R2:3 a)
(turn a b)=(map b a)

= (tabToRow a)
| listToRow
| listZip (listFromRow tabKeys-a) listFromRow-a

= (tabE a)
| NODE:37
| R1
| vecE
| turn tabToRow-a
& b
(NODE:61 (R2 (WORD (showNat (idx:0 b))) (idx:1 b)))

(varE a)=(WORD a)
(opnE a b c)=(NODE:42 (R3 (NODE:44 (map:varE a)) b c))
(TEXT a)=(R2:2 a)
(txtE a)=(TEXT a)
(EROR a)=a

= (zEnd a)
|
         ? (loop b c d)
         (if get-b-d c (ifNot d 3-c (loop b 3-c dec-d)))
      a
   0
| dec len-a

(nand a b)=(not and-a-b)
(gulf a b)=(gen (sub 3-b a) add-a)
(look a b)=(tabIdx b a)

= (even_2$even a)
. a
: (b c & b (R2:0 c))
:  ? (even_odd b)
   | match b 0
   | R2 (c @ idx:1 b)(ifNot c 1 (even_odd (R2:1 dec-c)))
   | (c @ idx:1 b)(ifNot c 0 (even_odd (R2:0 dec-c)))

(caar a)=(car car-a)
(cdar a)=(cdr car-a)
(cadr a)=(car cdr-a)
(cddr a)=(cdr cdr-a)
(xnor a b)=(not xor-a-b)
(dec32 a)=(2:4294967295:(b&b) a)
(inc32 a)=(w32 3-a)
(gte32 a b)=(gte w32-a w32-b)
(gth32 a b)=(gth w32-a w32-b)
(lth32 a b)=(lth w32-a w32-b)
(rol32 a b)=(or32 lsh32-a-b (rsh32 a (sub32:32 b)))
(eql32 a b)=(aeq w32-a w32-b)
(mul32 a b)=(w32 (mul w32-a w32-b))
(not32 a)=(not w32-a)
(div32 a b)=(div w32-a w32-b)
(appE2 a b)=(NODE:124 R2-a-b)
(lte48 a b)=(lte w48-a w48-b)

= (sub48 a b)
| if lte48-b-a (sub w48-a w48-b)
| sub (add:281474976710656 a) b

(dec48 a)=(2:281474976710655:(b&b) a)
(inc48 a)=(w48 3-a)
(add48 a b)=(w48 (add w48-a w48-b))
(gte48 a b)=(gte w48-a w48-b)
(gth48 a b)=(gth w48-a w48-b)
(lth48 a b)=(lth w48-a w48-b)
(eql48 a b)=(aeq w48-a w48-b)
(mul48 a b)=(w48 (mul w48-a w48-b))
(not48 a)=(not w48-a)
(div48 a b)=(div w48-a w48-b)

= (mkPin a)
@ b arity-a
| 0:0 b
| (go c d ? ifNot d 2-c (0 (go c dec-d) d)) a b

= (unApp a b)
| if isApp-a (unApp car-a (R2 cdr-a b))
| listToRow R2-a-b

(caaar a)=(car (car car-a))
(cdaar a)=(cdr (car car-a))
(cadar a)=(car (cdr car-a))
(cddar a)=(cdr (cdr car-a))
(caadr a)=(car (car cdr-a))
(cdadr a)=(cdr (car cdr-a))
(caddr a)=(car (cdr cdr-a))
(cdddr a)=(cdr (cdr cdr-a))

= (isCow a)
| and isFun-a
| and (eql:0 funName-a) (eql:0 funBody-a)

(isRow a)=(and (eql:1 arity-a) (isCow head-a))
(bitFlip32 a)=(sub32:4294967295 a)
(iNeg32 a)=(inc32 bitFlip32-a)
(iSub32 a b)=(add32 a iNeg32-b)
(iDec32 a)=(dec32 a)
(iInc32 a)=(inc32 a)
(iAdd32 a b)=(add32 a b)
(iIsNeg32 a)=(gth32 a 2147483647)

= (iGth32 a b)
| if iIsNeg32-a (and iIsNeg32-b (gth32 iNeg32-b iNeg32-a))
| or iIsNeg32-b gth32-a-b

(iGte32 a b)=(or eql32-a-b iGth32-a-b)
(iLte32 a b)=(iGte32 b a)
(iLth32 a b)=(iGth32 b a)
(iEql32 a b)=(eql32 a b)
(iMul32 a b)=(mul32 a b)
(iAbs32 a)=(if iIsNeg32-a iNeg32-a a)

= (iDiv32 a b)
@ c (div32 iAbs32-a iAbs32-b)
| if (R3:xor iIsNeg32-a iIsNeg32-a) iNeg32-c c

(bitFlip48 a)=(sub48:281474976710655 a)
(iNeg48 a)=(inc48 bitFlip48-a)
(iSub48 a b)=(add48 a iNeg48-b)
(iDec48 a)=(dec48 a)
(iInc48 a)=(inc48 a)
(iAdd48 a b)=(add48 a b)
(iIsNeg48 a)=(gth48 a 140737488355327)

= (iGth48 a b)
| if iIsNeg48-a (and iIsNeg48-b (gth48 iNeg48-b iNeg48-a))
| or iIsNeg48-b gth48-a-b

(iGte48 a b)=(or eql48-a-b iGth48-a-b)
(iLte48 a b)=(iGte48 b a)
(iLth48 a b)=(iGth48 b a)
(iEql48 a b)=(eql48 a b)
(iMul48 a b)=(mul48 a b)
(iAbs48 a)=(if iIsNeg48-a iNeg48-a a)

= (iDiv48 a b)
@ c (div48 iAbs48-a iAbs48-b)
| if (xor iIsNeg48-a iIsNeg48-a) iNeg48-c c

(matchE a b c)=(appE (R4 cnsE-match a b vecE-c))
(barDec a)=(sub a (bex (mul:8 (dec byteWidth-a))))
(runVec a)=(rowApply (idx:0 a) (drop:1 a))

= (barTrail a)
. a
:  ? (loop b c)
   | seq b
   | if (or (eql:1 c) (eql:0 c)) b
   | loop (ifNot mod-c-8 3-b 0) rsh-c-8
: 0

(barPad a)=(barTrail funBody-a)

= (unCell a b)
| if isNat-a (listToRow CONS-a-b)
| unApp car-a (CONS cdr-a b)

= (listMinimumOn a b c)
| if isNat-c b
@ d (idx:0 c)
| listMinimumOn a (if (lth a-d a-b) d b) (idx:1 c)

= (listFilter a b)
| if isNat-b 0
@ c (idx:0 b)
@ d (idx:1 b)
| if a-c (R2 c listFilter-a-d) listFilter-a-d

= (listSortOn a b)
| if isNat-b 0
@ c (listMinimumOn a (idx:0 b) (idx:1 b))
| R2 c
| listSortOn a
| listFilter ((d e f & not (eql e d-f)) a a-c) b

(sortOn a b)=(listToRow (listSortOn a listFromRow-b))

= (bytesBar a)
@ b zEnd-a
| mkBar b
| foldr:(c d & add c lsh-d-8):0
| map:w8 (take (sub len-a b) a)

(barGen a b)=(bytesBar gen-a-b)
(tabLen a)=(len (funBody head-a))
(barLen a)=(dec (byteWidth funBody-a))

= (looper a)
. (R2:0 a)
? (loop b)
(match b 0 (R1 (ifNot (idx:1 b) 0 (loop [0 0]))))

= (chunks a b)
| ifNot len-b []
|
         ? (loop c d e)
         (if (eql:0 len-d) e (loop c drop-c-d (e take-c-d)))
      a
   b
| mkRow (div (roundUp len-b a) a)

(barNat a)=(barDec funBody-a)
(takeByte a)=(takeBits:8 a)
(dropByte a)=(rsh a 8)

= (barIdx a b)
. a barNat-b
? (loop c d)
| ifNot c takeByte-d
| ifNot d 0 (loop dec-c dropByte-d)

(barGet a b)=(barIdx b a)

= (tabFromRow a)
@ b (sortOn:(idx-0) a)
| rowApply
   (0:0 (3 len-b) (map:(idx-0) b))
   (map:(idx-1) b)

(tabPut a b c)=(tabFromRow (weld tabToRow-a (R1 R2-b-c)))
(valRex a)=(TEXT 'EMBED VAL')

= (optionRowSequence a)
|  :  ? (loop b c)
      | if isNat-c (0 listToRowReversed-b)
      | if (isNat (idx:0 c)) 0
      | loop (CONS (cdr (idx:0 c)) b) (idx:1 c)
   : 0
| listFromRow-a

(optionRowTraverse a b)=(optionRowSequence map-a-b)
(tabSwitch a b c)=(ifNot (tabHas a c) b tabIdx-a-c)

= (readDigit a)
| tabSwitch a 0
. SOME-0
   SOME-1
   SOME-2
   SOME-3
   SOME-4
   SOME-5
   SOME-6
   SOME-7
   SOME-8
   SOME-9
%['0' '1' '2' '3' '4' '5' '6' '7' '8' '9']

= (readNat a)
| if (isNat (optionRowTraverse:readDigit explode-a)) 0
@ b (cdr (optionRowTraverse:readDigit explode-a))
| ifNot len-b 0
| 0
| idx:1
. b
: foldr
:  & (c d)
   (e @ idx:0 d)(R2 (mul:10 e) (add (idx:1 d) mul-e-c))
: [1 0]

= (readAtomLit a)
@ b (LEFT (R2 a 'Not an atom literal (readAtomLit)'))
| switch (idx:0 a) 0
| R5
            @ c (idx:2 a)
            | if
                  | rowOr
                  | R3 (neq:37 (idx:1 a)) (neq:0 (idx:3 a))
                  | neq:1 len-c
               b
            | switch (idx:0 (idx:0 c)) 0
            | R5 b (RIGHT (idx:1 (idx:0 c))) b b b
         @ c (readNat (idx:1 a))
         | if isNat-c (LEFT R2-a-b) (1 cdr-c)
      (RIGHT (idx:1 a))
   (RIGHT (idx:1 a))
| (c @ idx:1 a)(if isNat-c RIGHT-c b)

= (unrollSlip2Tis a b)
. a 0 b
? (loop c d e)
@ f loop-c
@ g (h @ c-e)(if car-h (f (CONS cdr-h d) 0) h)
| if (eql:0 e) (RIGHT listToRowReversed-d)
| switch (idx:0 e) 0
. g g g g
| R5
@ h (idx:2 e)
@ i (idx:3 e)
| if (neq:61 (idx:1 e)) g
@ j len-h
| if
   (and (eql:1 j) (neq:0 i))
   (f (CONS (R2 (idx:0 h) i) d) 0)
| if
   (neq:2 j)
   (LEFT (R2 e '= node expects two parameters'))
| f CONS-h-d i

= (readSignature a)
@ b
   | LEFT
   | R2 a
   '''Function Signature must be a symbol `x` or signature `(x y z)`
| switch (idx:0 a) 0
. b b b
| R5
   | if (neq (idx:1 a) 124) b
   | if (neq (idx:3 a) 0)
      | LEFT
      | R2 a
         '''name-sequence cannot have a continuation
   | eitherRowTraverse:readSymbol_1 (idx:2 a)
| (c @ readSymbol_1-a)(if car-c (R1 (idx:0 cdr-c)) c)

(readCorePattern a b)=(c @ readSignature-a)(if car-c (RIGHT (R2 cdr-c b)) c)

= (readCoreBody a)
@ b
   | unrollSlip2Tis:(c & LEFT (R2 c 'Not a core arm'))
   | a
| if
   car-b
   (eitherRowTraverse:(rowApply-readCorePattern) cdr-b)
| b

(anonLamE a b)=(HEIR:38 (R1 appE-a) b)

= (taggedLamE a b c d)
| HEIR:63 (R1 (appE (weld (R1 (NODE:36 (R2 a natE-b))) c)))
| d

= ('#mutrec' a b c d)
. a b c d
: gensymMacro
:
   '''#mutrec
: [readAtomLit RIGHT readCoreBody]
:  & (e f g h)
   @ i gensymE-e
   @ j (gensymE 3-e)
   @ k
      . i
      ? (bindArms i j k)
      | if isNat-k j
      @ l (idx:0 (idx:1 (idx:0 k)))
      @ m (map:WORD (drop:1 l))
      | letE (WORD (idx:0 l))
         | anonLamE m
         | appE
         | R2
            i
            (vecE (weld (R1 (natE (idx:0 (idx:0 k)))) m))
      | bindArms i j (idx:1 k)
   @ l (listZip listEnumFrom-0 listFromRow-h)
   | RIGHT
   | R2:2
   . k-g-l
   | letE i
   | taggedLamE i f R1-j
   . l
   | k
   | matchE j natE-0
   | turn listToRow-l
   . j
   & (i j)
   | NODE:42
   | R3
         | NODE:44
         | map:WORD
            (weld:[95] (drop:1 (idx:0 (idx:1 j))))
      i
   | idx:1 (idx:1 j)

= (barWeld a b)
@ c barLen-a
| barGen (add c barLen-b)
|
         & (d e f g)
         (if lth-g-f barIdx-g-d (barIdx sub-g-f e))
      a
   b
| c

(rebuild a)=(if isNat-a a (runVec map-rebuild-a))
(listAnd a)=(listFoldr:and:1 a)
(implode a)=(rap:8 a)

= (rexCase a b c d e f)
| switch (idx:0 a) 0
| R5
   (b (idx:1 a) (idx:2 a) (idx:3 a))
   (c (idx:1 a))
   (d (idx:1 a))
   (e (idx:1 a))
| f (idx:1 a)

(compose a b c)=(a b-c)

= (reverse a)
@ b len-a
| gen b ((c d e & get c (sub d 3-e)) a b)

(hexChar a)=(barGet:(b#0123456789abcdef) a)

= (hexByte a)
| implode
| map:hexChar (R2 (takeBits:4 rsh-a-4) (takeBits:4 a))

= (readSwitchPattern a)
| if (and (eql:1 (idx:0 a)) (eql:95 (idx:1 a))) RIGHT-0
| (b @ readAtomLit-a)(if car-b (RIGHT (SOME cdr-b)) b)

= (derpSwitchPattern a b)
@ c readSwitchPattern-a
| if car-c (RIGHT (R2 cdr-c b)) c

= (readSwitchPatterns a)
@ b (unrollSlip2Tis:(d & RIGHT (R2 WORD-95 d)) a)
. b
| if car-b
@ c (eitherRowTraverse:(rowApply-derpSwitchPattern) cdr-b)
. c
| if car-c
| RIGHT
. cdr-c
|  : foldl
   :  & (d e)
      @ f (idx:1 e)
      | if (isNat (idx:0 e)) put-d-0-f
      | put d 1 (tabPut (idx:1 d) (cdr (idx:0 e)) f)
| R2 cnsE-0 %[]

(tabValues a)=(map tabGet-a tabKeys-a)

= ('#switch' a b c d)
. a b c d
: simpleMacro
:
   '''#switch
: [RIGHT readSwitchPatterns]
:  & (e f)
   @ g (idx:0 f)
   @ h (idx:1 f)
   | RIGHT
   | if
         | listAnd
         | listZipWith:eql listEnumFrom-0
         | listFromRow tabKeys-h
      (appE (R4 cnsE-switch e g (vecE tabValues-h)))
   | appE (R4 cnsE-tabSwitch e g tabE-h)

(jarHash a)=(bytesBar (idx:0 jar-a))
(pinHash a)=(ifNot (isPin a) 0 (jarHash pinItem-a))
(listAll a b)=(listAnd listMap-a-b)
(listSum a)=(listFoldr:add:0 a)

= (niceJar a)
@ b jar-a
| %[hash deps bits] (bytesBar (idx:0 b)) (idx:1 b)
| bytesBar (idx:2 b)

= (inspect a)
| if isApp-a (unApp car-a (CONS cdr-a 0))
| if isFun-a (R4:0 funName-a funArgs-a funBody-a) a

(mkInput a)=(map:(b & mod-b-256) (gulf:0 dec-a))
('#getenv' a b c d)=(RIGHT (R2:0 cnsE-a))
(barConcat a)=(foldr:barWeld:(b#'') a)

= (barIntercalate a b)
|
         ? (go c d e)
         | if isNat-e d
         @ f (idx:0 e)
         @ g (idx:1 e)
         | if
            isNat-g
            barWeld-d-f
            (go c (barConcat R3-d-f-c) g)
      a
   b#''
| listFromRow-b

= (showRex a)
| switch (idx:0 a) 0
| R5
            @ b (idx:1 a)
            @ c (idx:2 a)
            @ d (idx:3 a)
            @ e
               | barConcat
               . b#')'
               | R3:(b#'(')
               | barIntercalate:(b#' ')
               | if eql-b-124 map-showRex-c
               | weld (R1 natBar-b) map-showRex-c
            | if eql-d-0 e (barWeld e showRex-d)
         (natBar (idx:1 a))
      (barConcat (R3:(b#'"') (natBar (idx:1 a)) b#'"'))
   (showRex (TEXT (cordConcat (idx:1 a))))
| showRex (valRex (idx:1 a))

(jarBytz a)=(bytesBar (idx:2 jar-a))
(pinBytz a)=(ifNot (isPin a) 0 (jarBytz pinItem-a))
(eitherMap a b)=(if car-b (RIGHT (a cdr-b)) (0 cdr-b))
(rexGetWord a b c)=(switch (idx:0 a) 0 (R5 b (c (idx:1 a)) b b b))

= (readTabPatternBinder a)
@ b
   | LEFT
   | R2 a (cordConcat ["Expected a '" 61 "' node"])
| switch (idx:0 a) 0
. b b b b
| R5
| if (neq:61 (idx:1 a)) b
@ c
   | LEFT
   | R2 a
      '''Tab-Binder must have form (= k) or (= k v)
| switch (len (mergeHeir (idx:2 a) (idx:3 a))) c
| R3 c
   @ d (LEFT 'Expected a word in Tab-Binder key')
   | switch
      (idx:0 (idx:0 (mergeHeir (idx:2 a) (idx:3 a))))
      0
   . d d d
   | R5 d
   @ e (idx:1 (idx:0 (mergeHeir (idx:2 a) (idx:3 a))))
   | RIGHT R2-e-e
| rexGetWord
   (idx:0 (mergeHeir (idx:2 a) (idx:3 a)))
   (LEFT 'Expected a word in Tab-Binder key')
|  & (f g)
   | rexGetWord
      f
      (LEFT 'Expected a word in Tab-Binder value')
   | (f g & RIGHT R2-f-g) g
| idx:1 (mergeHeir (idx:2 a) (idx:3 a))

= (readTabPattern a)
@ b
   | LEFT
   | R2 a (cordConcat ["Expected a '" 37 "' node"])
| switch (idx:0 a) 0
. b b b b
| R5
| if (neq:37 (idx:1 a)) b
| if (neq:1 (len (mergeHeir (idx:2 a) (idx:3 a))))
   | LEFT
   | R2
      a
      '''Tab-Pattern expects % rune with one parameter
@ c (idx:0 (mergeHeir (idx:2 a) (idx:3 a)))
@ d
   | LEFT
   | R2 c (cordConcat ["Expected a '" 44 "' node"])
| switch (idx:0 c) 0
. d d d d
| R5
| if (neq:44 (idx:1 c)) d
| eitherMap:tabFromRow
| eitherRowTraverse:readTabPatternBinder
| mergeHeir (idx:2 c) (idx:3 c)

(tabToList a)=(listFromRow tabToRow-a)

= ('#openTab' a b c d)
. a b c d
: gensymMacro
:
   '''#openTab
: [readTabPattern RIGHT RIGHT]
:  & (e f g h)
   | deepseq f
   @ i (gensymE %tab)
   | RIGHT
   | R2:1
   | letE i g
   |
            ? (bindSlotsLoop f g h)
            | if isNat-h f
            | letE
               (WORD (idx:1 (idx:0 h)))
               (appE (R3 cnsE-tabIdx (cnsE (idx:0 (idx:0 h))) g))
            | bindSlotsLoop f g (idx:1 h)
         h
      i
   | tabToList-f

(listHead a)=(if isNat-a 0 (SOME (idx:0 a)))
(listWeld a b)=(if isNat-a b (R2 (idx:0 a) (listWeld (idx:1 a) b)))

= (showTreeBar a)
| if isNat-a
   | if okaySymbol-a (barWeld:(b#'%') natBar-a)
   | natBar showNat-a
| barConcat
. b#')'
| R3:(b#'(')
| barIntercalate:(b#' ')
| map showTreeBar (unCell car-a (CONS cdr-a 0))

(showTree a)=(barNat showTreeBar-a)

= (listTake a b)
| ifNot a 0
| if isNat-b 0
| R2 (idx:0 b) (listTake dec-a (idx:1 b))

(fromSome a b)=(if isNat-b a cdr-b)
(listCase a b c)=(if isNat-a b (c (idx:0 a) (idx:1 a)))
(showByte a)=(blockWeld:16:(%0x) hexByte-a)
(tabMatch a b c)=(tabSwitch (idx:0 a) b c)
(showHash a)=(cordWeld:(%0x) (rap:16 (map:hexByte a)))
(barBytes a)=(gen barLen-a barGet-a)
(barFoldl a b c)=(foldl a b barBytes-c)
(listNull a)=(aeqZero (idx:0 a))
(listTurn a b)=(listMap b a)
(listDrop a b)=(ifNot a b (if isNat-b 0 (listDrop dec-a (idx:1 b))))
(barFoldr a b c)=(foldr a b barBytes-c)

= (natWords a)
. [%Zero]
| switch a
. natWords a
? (loop b c)
| switch c (cordConcat (R2 (loop b div-c-10) (b mod-c-10)))
,, 0
,, %One
,, %Two
,, %Three
,, %Four
,, %Five
,, %Six
,, %Seven
,, %Eight
,, %Nine

(fromLeft a b)=(if car-b (a cdr-b) cdr-b)
(iIsZero32 a)=(not32 a)

= (showTree2 a)
| if isNat-a a
| R2 (showTree2 car-a) (showTree2 cdr-a)

(iIsZero48 a)=(not48 a)
(stripZEnd a)=(take (sub len-a zEnd-a) a)

= (refsTable a)
| tabFromRow
| turn refs-a (b & R2 (funName pinItem-b) pinHash-b)

(maybeCase a b c)=(if isNat-a b (c cdr-a))
(concatMap a b)=(concat map-a-b)
(fromRight a b)=(if car-b cdr-b (a cdr-b))

= (rexGetNode a b c)
| switch (idx:0 a) 0
| R5 (c (idx:1 a) (idx:2 a) (idx:3 a)) b b b b

(eitherCase a b c)=(if car-a (c cdr-a) (b cdr-a))
(eitherOpen a b)=(if car-a (b cdr-a) a)
(fromEither a b c)=(if car-c (b cdr-c) (a cdr-c))

= (listConcat a)
| if isNat-a 0
| listWeld (idx:0 a) (listConcat (idx:1 a))

= (switchTest a)
| tabSwitch a b#hur
| %[345=(b#345) 346=(b#346) hi=(b#hi) yop=(b#yop)]

(rexGetText a b c)=(switch (idx:0 a) 0 (R5 b b (c (idx:1 a)) b b))

= (switchTest2 a)
| switch a %Other
| R4:(%Zero):(%One):(%Two) (barNat b#Three)

(switchTest3 a)=(switch a %Fallback [%Zero %One %Two])

= (readNatWord a)
@ b
   '''Not an atom literal (readNatWord)
@ c (LEFT R2-a-b)
| switch (idx:0 a) 0
. c c c
| R5 c
@ d (readNat (idx:1 a))
| if isNat-d (LEFT R2-a-b) (1 cdr-d)

(listSafeHead a b)=(if isNat-b a (idx:0 b))
(readNatEither a b c)=(d @ readNat-c)(if isNat-d (LEFT R2-a-b) (1 cdr-d))

= (readBindPairs a)
@ b
   . a
   :  ? (loop c d)
      | trk (R3:(%loop) (%[acc] c) (%[more] d))
      | if (eql:0 d) RIGHT-c
      @ e
         | LEFT
         | R2
            d
            '''Knot binders must be an = node with 2 kids
      | switch (idx:0 d) 0
      . e e e e
      | R5
      @ f (idx:2 d)
      | if (neq:61 (idx:1 d)) e
      | if (neq:2 len-f) e
      @ g (readSymbol_1 (idx:0 f))
      . g
      | if car-g
      | loop
         (CONS (R2 (cdr cdr-g) (idx:1 f)) c)
         (idx:3 d)
   : 0
| if car-b (RIGHT (listToRowReversed cdr-b)) b

(listUnsafeHead a)=(listSafeHead:0)
(| 0)=(b#'(= (showRex expr))(! rexCase expr (& (r x k))(@ hed (barConcat)(,, (# b "("))(,, (barIntercalate (# b " "))(if (eql r "|") (- map showRex x))(weld (, (- natBar r)) (- map showRex x)))(,, (# b ")")))(if (eql k 0) hed)(barWeld hed (- showRex k)) (& name (natBar name)) (& cord (barConcat (, (# b """) (- natBar cord) (# b """)))) (& page (showRex (TEXT (- cordConcat page)))) (& cnst (showRex (- valRex cnst))))')
(fullInspection a)=(b @ inspect-a)(if isNat-b b map-fullInspection-b)
(eitherCaseLeft a b c)=(if car-a (b cdr-a) (c cdr-a))
(eitherOpenLeft a b)=(if car-a a (b cdr-a))

= (rexGetNodeFolded a b c)
| switch (idx:0 a) 0
| R5 (c (idx:1 a) (mergeHeir (idx:2 a) (idx:3 a))) b b b
| b

= (readSpecificRuneFolded a b c)
@ d
   | LEFT
   | R2 b (cordConcat (R3:"Expected a '" a "' node"))
| switch (idx:0 b) 0
. d d d d
| R5
| if (neq a (idx:1 b)) d
| c (mergeHeir (idx:2 b) (idx:3 b))

= _
%% =4 0
%% ='#'
%% ='*' $'#openRow'
%% =F 0
%% =I
%% =K
%% =N 0
%% =S
%% =T 1
%% =Y 1
%% =_
   %% ='#'
   %% ='*' $'#openRow'
   %% =F 0
   %% =I
   %% =K
   %% =N 0
   %% =S
   %% =T 1
   %% =Y 1
   %% ='`'
   %% ='~'
   %% ='#*'
   %% =w8
   %% ='/='
   %% ='=='
   %% ='#@'
   %% ='#b' barLit 98 natBar
   %% =if
   %% =or
   %% ='#x' barLit 120 barFromHex
   %% ='~~'
   %% =i32
   %% =w32
   %% =i48
   %% =w48
   %% =NIL 0
   %% =sub
   %% =dec
   %% =inc 3
   %% =add
   %% =odd
   %% =and
   %% =mod
   %% =die
   %% =gte
   %% =lte
   %% =lsh
   %% =rsh
   %% =gth
   %% =lth
   %% =trk
   %% =all
   %% =eql
   %% =mul
   %% =jam
   %% =sum
   %% =gen
   %% =len
   %% =min
   %% =con
   %% =map
   %% =rap
   %% =zip
   %% =aeq
   %% =neq
   %% =seq
   %% =car
   %% =jar
   %% =cdr
   %% =nor
   %% =xor
   %% =has
   %% =dis
   %% =mat
   %% =get
   %% =not
   %% =put
   %% =div
   %% =max
   %% =idx
   %% =bex
   %% =mix
   %% =any
   %% =or32
   %% =WORD
   %% =NODE
   %% =PAGE
   %% =SOME
   %% =NONE 0
   %% =tabE
   %% =vecE
   %% =opnE
   %% =appE
   %% =varE
   %% =cnsE
   %% =natE
   %% =letE
   %% =txtE
   %% =HEIR
   %% =EROR
   %% =CONS
   %% =LEFT
   %% =TEXT
   %% =VRAW
   %% =head
   %% =weld
   %% =zEnd
   %% =nand
   %% =find
   %% =take
   %% =gulf
   %% =look
   %% =even even_2
   %% =turn
   %% =drop
   %% =caar
   %% =cdar
   %% =cadr
   %% =cddr
   %% =xnor
   %% =refs
   %% =sub32
   %% =dec32
   %% =inc32
   %% =add32
   %% =and32
   %% =gte32
   %% =lte32
   %% =lsh32
   %% =rsh32
   %% =gth32
   %% =lth32
   %% =rol32
   %% =eql32
   %% =mul32
   %% =ror32
   %% =xor32
   %% =not32
   %% =div32
   %% =appE2
   %% =sub48
   %% =dec48
   %% =inc48
   %% =add48
   %% =gte48
   %% =lte48
   %% =gth48
   %% =lth48
   %% =eql48
   %% =mul48
   %% =not48
   %% =div48
   %% =RIGHT
   %% =force
   %% =match
   %% =foldl
   %% =mkPin
   %% =isPin
   %% =mkFun 0
   %% =isFun
   %% =unApp
   %% =isApp
   %% =rowOr
   %% =mkBar
   %% =caaar
   %% =cdaar
   %% =cadar
   %% =cddar
   %% =caadr
   %% =cdadr
   %% =caddr
   %% =cdddr
   %% =foldr
   %% =toNat
   %% =isNat
   %% =ifNot
   %% =isCow
   %% =mkRow
   %% =isRow
   %% =apply
   %% =arity
   %% =iSub32
   %% =iDec32
   %% =iInc32
   %% =iAdd32
   %% =iGte32
   %% =iLte32
   %% =iNeg32
   %% =iGth32
   %% =iLth32
   %% =iEql32
   %% =iMul32
   %% =iMin32 2147483648
   %% =wMin32 0
   %% =chop32
   %% =iAbs32
   %% =iDiv32
   %% =iMax32 2147483647
   %% =wMax32 4294967295
   %% =blake3
   %% =iSub48
   %% =iDec48
   %% =iInc48
   %% =iAdd48
   %% =iGte48
   %% =iLte48
   %% =iNeg48
   %% =iGth48
   %% =iLth48
   %% =iEql48
   %% =iMul48
   %% =iMin48 140737488355328
   %% =wMin48 0
   %% =iAbs48
   %% =iDiv48
   %% =iMax48 140737488355327
   %% =wMax48 281474976710655
   %% =matchE
   %% =barDec
   %% =runVec
   %% =barEnc
   %% =barPad
   %% =rowAnd
   %% =splice
   %% =update
   %% =switch
   %% =trkVal
   %% =unCell
   %% =toBool
   %% =sortOn
   %% =barGen
   %% =tabLen
   %% =barLen
   %% =listOr
   %% =natBar
   %% =looper
   %% =mkHeir
   %% =tabHas
   %% =chunks
   %% =digits
   %% =barNat
   %% =concat
   %% =tabGet
   %% =barGet
   %% =tabPut
   %% =tabIdx
   %% =barIdx
   %% =valRex
   %% =appify
   %% =supply
   %% =gensymE
   %% =isAlpha
   %% ='#mutrec'
   %% =appHead
   %% =evenOdd [even_2 odd]
   %% =barWeld
   %% =rebuild
   %% =listAnd
   %% =implode
   %% =explode
   %% =funName
   %% =valCase 1
   %% =natCase 2
   %% =rexCase
   %% =compose
   %% =reverse
   %% =hexByte
   %% ='#switch'
   %% =pinHash
   %% =jarHash
   %% =zipWith
   %% =appTail
   %% =listAll
   %% =pinItem
   %% =listSum
   %% =listLen
   %% =loopFun
      ? (looper a)
      . (R2:0 a)
      ? (loop b)
      (match b 0 (R1 (ifNot (idx:1 b) 0 (loop [0 0]))))
   %% =aeqZero
   %% =roundUp
   %% =listMap
   %% =listZip
   %% =deepseq
   %% =niceJar
   %% =hexChar
   %% =isUpper
   %% =isLower
   %% =listHas
   %% =funArgs
   %% =tabKeys
   %% =readNat
   %% =showNat
   %% =inspect
   %% =isDigit
   %% =mkInput
   %% ='#getenv'
   %% =showRex
   %% =funBody
   %% =listAny
   %% =pinBytz
   %% =jarBytz
   %% =iIsNeg32
   %% =isZero32 not32
   %% =iIsNeg48
   %% =isZero48 not48
   %% =anonLamE
   %% ='#openTab'
   %% =listHead
   %% =cordWeld
   %% =listWeld
   %% =showTree
   %% =listTake
   %% =fromSome
   %% =listCase
   %% =takeByte
   %% =dropByte
   %% =showByte
   %% =tabMatch
   %% =showHash
   %% =bitWidth
   %% =barFoldl
   %% =barTrail
   %% =listNull
   %% =listTurn
   %% =listDrop
   %% =bytesBar
   %% =barFoldr
   %% =natWords
   %% =barBytes
   %% =takeBits
   %% =fromLeft
   %% ='#openRow'
   %% =tabToRow
   %% =rowApply
   %% =iIsZero32
   %% =bitFlip32
   %% =showTree2
   %% =iIsZero48
   %% =bitFlip48
   %% =blockWeld
   %% =stripZEnd
   %% =refsTable
   %% =maybeCase
   %% =replicate
   %% =tabSwitch
   %% =byteWidth
   %% =listFoldl
   %% =eitherMap
   %% =concatMap
   %% =listFoldr
   %% =mergeHeir
   %% =tabValues
   %% =barConcat
   %% =fromRight
   %% =readDigit
   %% =tabToList
   %% =listToRow
   %% =taggedLamE
   %% =rexGetWord
   %% =rexGetNode
   %% =eitherCase
   %% =readSymbol readSymbol_1
   %% =okaySymbol
   %% =listSortOn
   %% =eitherOpen
   %% =listLookup
   %% =fromEither
   %% =listFilter
   %% =listDigits
   %% =cordConcat
   %% =listConcat
   %% =switchTest
   %% =rexGetText
   %% =tabFromRow
   %% =barFromHex
   %% =unrollSlip2
   %% =switchTest2
   %% =switchTest3
   %% =readNatWord
   %% =listZipWith
   %% =simpleMacro
   %% =gensymMacro
   %% =showTreeBar
   %% =hexAlphabet b#0123456789abcdef
   %% =dropHighBit
   %% =readAtomLit
   %% =listFromRow
   %% =listSafeHead
   %% =listEnumFrom
   %% =hexCharToNat
   %% =readCoreBody
   %% =readSignature
   %% =listMinimumOn
   %% =readNatEither
   %% =readBindPairs
   %% =listUnsafeHead
   %% =showRexExample $0
   %% =barIntercalate
   %% =fullInspection
   %% =readTabPattern
   %% =okaySymbolChar
   %% =readRowOfNames readRowOfNames_1
   %% =unrollSlip2Tis
   %% =eitherCaseLeft
   %% =eitherOpenLeft
   %% =readCorePattern
   %% =rexGetNodeFolded
   %% =listToRowReversed
   %% =optionRowSequence
   %% =eitherRowSequence
   %% =optionRowTraverse
   %% =eitherRowTraverse
   %% =readSwitchPattern
   %% =derpSwitchPattern
   %% =readSwitchPatterns
   %% =readTabPatternBinder
   %% =readSpecificRuneFolded
   %% =DLZ7asf6Z8JKVJh7XYdPE2vvchwLi8SYDqg1KdmRPGWM mul
   %% =DmQSboknWfMEi5VSrqzM5AkXNcmEJAagtGum48t9D5yY add
%% ='`'
%% ='~'
%% ='#*'
%% =k4 0
%% =w8
%% ='/='
%% ='=='
%% ='#@'
%% ='#b' barLit 98 natBar
%% =if
%% =or
%% ='#x' barLit 120 barFromHex
%% ='~~'
%% =i32
%% =w32
%% =i48
%% =w48
%% =NIL 0
%% =sub
%% =dec
%% =inc 3
%% =add
%% =odd
%% =and
%% =mod
%% =die
%% =gte
%% =lte
%% =lsh
%% =rsh
%% =gth
%% =lth
%% =trk
%% =all
%% =eql
%% =mul
%% =jam
%% =sum
%% =gen
%% =len
%% =min
%% =con
%% =map
%% =rap
%% =zip
%% =aeq
%% =neq
%% =seq
%% =car
%% =jar
%% =cdr
%% =nor
%% =xor
%% =has
%% =dis
%% =mat
%% =get
%% =not
%% =put
%% =div
%% =max
%% =idx
%% =bex
%% =mix
%% =any
%% =or32
%% =WORD
%% =NODE
%% =PAGE
%% =SOME
%% =NONE 0
%% =tabE
%% =vecE
%% =opnE
%% =appE
%% =varE
%% =cnsE
%% =natE
%% =letE
%% =txtE
%% =HEIR
%% =EROR
%% =CONS
%% =LEFT
%% =TEXT
%% =VRAW
%% =head
%% =weld
%% =zEnd
%% =nand
%% =find
%% =take
%% =gulf
%% =look
%% =even even_2
%% =turn
%% =drop
%% =caar
%% =cdar
%% =cadr
%% =cddr
%% =xnor
%% =refs
%% =tags [0 0]
%% =sub32
%% =dec32
%% =inc32
%% =add32
%% =and32
%% =gte32
%% =lte32
%% =lsh32
%% =rsh32
%% =gth32
%% =lth32
%% =rol32
%% =eql32
%% =mul32
%% =ror32
%% =xor32
%% =not32
%% =div32
%% =appE2
%% =sub48
%% =dec48
%% =inc48
%% =add48
%% =gte48
%% =lte48
%% =gth48
%% =lth48
%% =eql48
%% =mul48
%% =not48
%% =div48
%% =RIGHT
%% =force
%% =match
%% =foldl
%% =mkPin
%% =isPin
%% =mkFun 0
%% =isFun
%% =unApp
%% =isApp
%% =rowOr
%% =mkBar
%% =caaar
%% =cdaar
%% =cadar
%% =cddar
%% =caadr
%% =cdadr
%% =caddr
%% =cdddr
%% =foldr
%% =toNat
%% =isNat
%% =ifNot
%% =isCow
%% =mkRow
%% =isRow
%% =apply
%% =arity
%% =iSub32
%% =iDec32
%% =iInc32
%% =iAdd32
%% =iGte32
%% =iLte32
%% =iNeg32
%% =iGth32
%% =iLth32
%% =iEql32
%% =iMul32
%% =iMin32 2147483648
%% =wMin32 0
%% =chop32
%% =iAbs32
%% =iDiv32
%% =iMax32 2147483647
%% =wMax32 4294967295
%% =blake3
%% =iSub48
%% =iDec48
%% =iInc48
%% =iAdd48
%% =iGte48
%% =iLte48
%% =iNeg48
%% =iGth48
%% =iLth48
%% =iEql48
%% =iMul48
%% =iMin48 140737488355328
%% =wMin48 0
%% =iAbs48
%% =iDiv48
%% =iMax48 140737488355327
%% =wMax48 281474976710655
%% =matchE
%% =barDec
%% =runVec
%% =barEnc
%% =barPad
%% =rowAnd
%% =splice
%% =update
%% =switch
%% =trkVal
%% =unCell
%% =toBool
%% =sortOn
%% =barGen
%% =tabLen
%% =barLen
%% =listOr
%% =natBar
%% =looper
%% =mkHeir
%% =tabHas
%% =chunks
%% =digits
%% =barNat
%% =concat
%% =tabGet
%% =barGet
%% =tabPut
%% =tabIdx
%% =barIdx
%% =valRex
%% =appify
%% =supply
%% =gensymE
%% =isAlpha
%% ='#mutrec'
%% =appHead
%% =evenOdd [even_2 odd]
%% =barWeld
%% =rebuild
%% =listAnd
%% =implode
%% =explode
%% =funName
%% =valCase 1
%% =natCase 2
%% =rexCase
%% =compose
%% =reverse
%% =hexByte
%% ='#switch'
%% =pinHash
%% =jarHash
%% =zipWith
%% =appTail
%% =listAll
%% =pinItem
%% =listSum
%% =listLen
%% =loopFun
   ? (looper a)
   . (R2:0 a)
   ? (loop b)
   (match b 0 (R1 (ifNot (idx:1 b) 0 (loop [0 0]))))
%% =aeqZero
%% =roundUp
%% =listMap
%% =listZip
%% =deepseq
%% =niceJar
%% =hexChar
%% =isUpper
%% =isLower
%% =listHas
%% =funArgs
%% =tabKeys
%% =readNat
%% =showNat
%% =inspect
%% =isDigit
%% =mkInput
%% ='#getenv'
%% =showRex
%% =funBody
%% =listAny
%% =pinBytz
%% =jarBytz
%% =iIsNeg32
%% =isZero32 not32
%% =iIsNeg48
%% =isZero48 not48
%% =anonLamE
%% ='#openTab'
%% =listHead
%% =cordWeld
%% =listWeld
%% =showTree
%% =listTake
%% =fromSome
%% =listCase
%% =takeByte
%% =dropByte
%% =showByte
%% =tabMatch
%% =showHash
%% =bitWidth
%% =barFoldl
%% =barTrail
%% =listNull
%% =listTurn
%% =listDrop
%% =bytesBar
%% =barFoldr
%% =natWords
%% =barBytes
%% =takeBits
%% =fromLeft
%% ='#openRow'
%% =tabToRow
%% =rowApply
%% =iIsZero32
%% =bitFlip32
%% =showTree2
%% =iIsZero48
%% =bitFlip48
%% =blockWeld
%% =stripZEnd
%% =refsTable
%% =maybeCase
%% =replicate
%% =tabSwitch
%% =byteWidth
%% =listFoldl
%% =eitherMap
%% =concatMap
%% =listFoldr
%% =mergeHeir
%% =tabValues
%% =barConcat
%% =fromRight
%% =readDigit
%% =tabToList
%% =listToRow
%% =taggedLamE
%% =rexGetWord
%% =rexGetNode
%% =eitherCase
%% =readSymbol readSymbol_1
%% =okaySymbol
%% =listSortOn
%% =eitherOpen
%% =listLookup
%% =fromEither
%% =listFilter
%% =listDigits
%% =cordConcat
%% =listConcat
%% =switchTest
%% =rexGetText
%% =tabFromRow
%% =barFromHex
%% =unrollSlip2
%% =switchTest2
%% =switchTest3
%% =readNatWord
%% =listZipWith
%% =simpleMacro
%% =gensymMacro
%% =showTreeBar
%% =hexAlphabet b#0123456789abcdef
%% =dropHighBit
%% =readAtomLit
%% =listFromRow
%% =listSafeHead
%% =listEnumFrom
%% =hexCharToNat
%% =readCoreBody
%% =readSignature
%% =listMinimumOn
%% =readNatEither
%% =readBindPairs
%% =listUnsafeHead
%% =showRexExample $0
%% =barIntercalate
%% =fullInspection
%% =readTabPattern
%% =okaySymbolChar
%% =readRowOfNames readRowOfNames_1
%% =unrollSlip2Tis
%% =eitherCaseLeft
%% =eitherOpenLeft
%% =readCorePattern
%% =rexGetNodeFolded
%% =listToRowReversed
%% =optionRowSequence
%% =eitherRowSequence
%% =optionRowTraverse
%% =eitherRowTraverse
%% =readSwitchPattern
%% =derpSwitchPattern
%% =readSwitchPatterns
%% =readTabPatternBinder
%% =readSpecificRuneFolded
%% =DLZ7asf6Z8JKVJh7XYdPE2vvchwLi8SYDqg1KdmRPGWM mul
%% =DmQSboknWfMEi5VSrqzM5AkXNcmEJAagtGum48t9D5yY add


_hash=(x#8084dddc42766ffc13b5e8ab8adf9a5c737b7888044614bed75c06a8131b830d)

